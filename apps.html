<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apps - Crypto Tools</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<script>
(function() {
    'use strict';
    
    let currentTool = null;
    
    function toggleTool(toolId, event) {
        if (event) event.stopPropagation();
        
        console.log('üöÄ Abriendo:', toolId);
        
        const allTools = document.querySelectorAll('.tool-form');
        const targetTool = document.getElementById(toolId);
        
        if (!targetTool) {
            console.log('‚ùå No encontrado:', toolId);
            return;
        }
        
        if (currentTool === toolId) {
            targetTool.classList.remove('active');
            currentTool = null;
        } else {
            allTools.forEach(tool => tool.classList.remove('active'));
            targetTool.classList.add('active');
            currentTool = toolId;
            targetTool.scrollIntoView({ behavior: 'smooth' });
        }
    }
    
    document.addEventListener('click', function(e) {
        const toolHeader = e.target.closest('[data-tool]');
        if (toolHeader) {
            const toolId = toolHeader.getAttribute('data-tool');
            toggleTool(toolId, e);
        }
    });
    
})();
</script>
    <header class="site-header">
    <div class="header-left">
        <img src="Logo (Dark Mode).jpg" alt="Crypto Tools Pro" class="site-logo">
        <h1>Crypto Tools Pro</h1>
    </div>
    <div class="header-right">
        <nav>
            <ul class="site-nav">
                <li><a href="index.html">Home</a></li>
                <li><a href="apps.html">Apps</a></li>
                <li><a href="news.html">News</a></li>
                <li><a href="blog.html">Blog</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
        </nav>
        <div class="header-accent">
            <span class="status-dot"></span>
            <span>Live Market Data</span>
        </div>
    </div>
</header>
<div class="tool-header" data-tool="apps">
   <div class="header-content">
       <div class="header-left">
           <span class="tool-icon">üöÄ</span>
           <div class="title-section">
               <h3 class="tool-title">APPS</h3>
               <span class="tool-subtitle">Professional Trading & Analytics Suite</span>
           </div>
       </div>
       <div class="header-right">
           <span class="apps-count">12+ Tools</span>
           <div class="status-indicator">
               <span class="status-dot"></span>
               <span class="status-text">Live Data</span>
           </div>
       </div>
   </div>
</div>
<p class="tool-description">
   <span class="highlight">Real-time market data</span> ‚Ä¢ Portfolio tracking ‚Ä¢ Technical analysis ‚Ä¢ Risk management ‚Ä¢ Performance metrics
</p>

<div class="tool-form" id="apps">
   <!-- Portfolio Tracker Tool -->
   <div class="app-module">
       <div class="module-header">
           <span class="module-icon">üìä</span>
           <h4 class="module-title">Portfolio Tracker</h4>
           <span class="module-badge">Premium</span>
       </div>
       
       <div class="form-grid">
           <div class="form-group">
               <label>Select Cryptocurrency:</label>
               <select id="portfolioCoin" class="enhanced-select">
                   <option value="bitcoin">Bitcoin (BTC) - $67,420</option>
                   <option value="ethereum">Ethereum (ETH) - $3,240</option>
                   <option value="solana">Solana (SOL) - $158</option>
                   <option value="cardano">Cardano (ADA) - $0.48</option>
                   <option value="chainlink">Chainlink (LINK) - $14.20</option>
                   <option value="polygon">Polygon (MATIC) - $0.72</option>
               </select>
           </div>
           
           <div class="form-group">
               <label>Holdings Amount:</label>
               <div class="input-wrapper">
                   <input type="number" id="portfolioAmount" placeholder="0.00000000" step="any" class="precision-input">
                   <span class="input-suffix">Units</span>
               </div>
           </div>
           
           <div class="form-group">
               <label>Average Buy Price (USD):</label>
               <div class="input-wrapper">
                   <span class="input-prefix">$</span>
                   <input type="number" id="purchasePrice" placeholder="0.00" step="0.01" class="price-input">
               </div>
           </div>
           
           <div class="form-group">
               <label>Investment Date:</label>
               <input type="date" id="investmentDate" class="date-input">
           </div>
       </div>
       
       <div class="action-buttons">
           <button class="btn btn-primary" onclick="calculatePortfolio()">
               <span class="btn-icon">üìà</span>
               Analyze Portfolio
           </button>
           <button class="btn btn-secondary" onclick="exportData()">
               <span class="btn-icon">üì§</span>
               Export Data
           </button>
       </div>
       
       <div class="result enhanced-result" id="portfolioResult">
           <div class="result-placeholder">
               <span class="placeholder-icon">üí∞</span>
               <p>Enter your portfolio details to see real-time performance analysis</p>
           </div>
       </div>
   </div>
</div>

            <!-- DCA Calculator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="dca">
                    <span class="tool-icon">üí∞</span>
                    <h3 class="tool-title">DCA Calculator</h3>
                </div>
                <p class="tool-description">Calculate Dollar Cost Averaging returns for any cryptocurrency</p>
                <div class="tool-form" id="dca">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="dcaCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Investment Amount (USD):</label>
                        <input type="number" id="dcaAmount" placeholder="100" step="any">
                    </div>
                    <div class="form-group">
                        <label>Frequency:</label>
                        <select id="dcaFrequency">
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                            <option value="daily">Daily</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Time Period (months):</label>
                        <input type="number" id="dcaPeriod" placeholder="12" min="1" max="60">
                    </div>
                    <button class="btn" onclick="calculateDCA()">Calculate DCA</button>
                    <div class="result" id="dcaResult"></div>
                </div>
            </div>

            <!-- Bitcoin Calculator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="bitcoin">
                    <span class="tool-icon">‚Çø</span>
                    <h3 class="tool-title">Bitcoin Calculator</h3>
                </div>
                <p class="tool-description">Advanced Bitcoin calculations and conversions</p>
                <div class="tool-form" id="bitcoin">
                    <div class="form-group">
                        <label>Bitcoin Amount:</label>
                        <input type="number" id="btcAmount" placeholder="1.0" step="any">
                    </div>
                    <div class="form-group">
                        <label>Target Currency:</label>
                        <select id="btcCurrency">
                            <option value="usd">USD</option>
                            <option value="eur">EUR</option>
                            <option value="gbp">GBP</option>
                            <option value="jpy">JPY</option>
                        </select>
                    </div>
                    <button class="btn" onclick="calculateBitcoin()">Calculate Value</button>
                    <div class="result" id="bitcoinResult"></div>
                </div>
            </div>

            <!-- Exchange Comparator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="exchange">
                    <span class="tool-icon">‚öñÔ∏è</span>
                    <h3 class="tool-title">Exchange Comparator</h3>
                </div>
                <p class="tool-description">Compare cryptocurrency prices across different exchanges</p>
                <div class="tool-form" id="exchange">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="exchangeCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Amount:</label>
                        <input type="number" id="exchangeAmount" placeholder="1.0" step="any">
                    </div>
                    <button class="btn" onclick="compareExchanges()">Compare Prices</button>
                    <div class="result" id="exchangeResult"></div>
                </div>
            </div>

            <!-- Price Alerts -->
            <div class="tool-card">
                <div class="tool-header" data-tool="alerts">
                    <span class="tool-icon">üîî</span>
                    <h3 class="tool-title">Price Alerts</h3>
                </div>
                <p class="tool-description">Set price alerts for your favorite cryptocurrencies</p>
                <div class="tool-form" id="alerts">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="alertCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Target Price (USD):</label>
                        <input type="number" id="targetPrice" placeholder="50000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Alert Type:</label>
                        <select id="alertType">
                            <option value="above">Above Target</option>
                            <option value="below">Below Target</option>
                        </select>
                    </div>
                    <button class="btn" onclick="setAlert()">Set Alert</button>
                    <div class="result" id="alertResult"></div>
                </div>
            </div>

            <!-- Fear & Greed Calculator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="feargreed">
                    <span class="tool-icon">üò±</span>
                    <h3 class="tool-title">Fear & Greed Calculator</h3>
                </div>
                <p class="tool-description">Analyze market sentiment with Fear & Greed Index</p>
                <div class="tool-form" id="feargreed">
                    <div class="form-group">
                        <label>Market Cap Change (%):</label>
                        <input type="number" id="marketCapChange" placeholder="5.2" step="any">
                    </div>
                    <div class="form-group">
                        <label>Volume Change (%):</label>
                        <input type="number" id="volumeChange" placeholder="12.5" step="any">
                    </div>
                    <div class="form-group">
                        <label>Social Media Mentions:</label>
                        <input type="number" id="socialMentions" placeholder="1000" min="0">
                    </div>
                    <button class="btn" onclick="calculateFearGreed()">Calculate Index</button>
                    <div class="result" id="feargreedResult"></div>
                </div>
            </div>

            <!-- Tax Calculator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="tax">
                    <span class="tool-icon">üßæ</span>
                    <h3 class="tool-title">Tax Calculator</h3>
                </div>
                <p class="tool-description">Calculate crypto taxes and capital gains</p>
                <div class="tool-form" id="tax">
                    <div class="form-group">
                        <label>Purchase Price (USD):</label>
                        <input type="number" id="taxPurchasePrice" placeholder="30000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Sale Price (USD):</label>
                        <input type="number" id="taxSalePrice" placeholder="35000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Amount:</label>
                        <input type="number" id="taxAmount" placeholder="1.0" step="any">
                    </div>
                    <div class="form-group">
                        <label>Tax Rate (%):</label>
                        <input type="number" id="taxRate" placeholder="20" min="0" max="100">
                    </div>
                    <button class="btn" onclick="calculateTax()">Calculate Tax</button>
                    <div class="result" id="taxResult"></div>
                </div>
            </div>

            <!-- Technical Analysis -->
            <div class="tool-card">
                <div class="tool-header" data-tool="technical">
                    <span class="tool-icon">üìà</span>
                    <h3 class="tool-title">Technical Analysis</h3>
                </div>
                <p class="tool-description">Advanced technical analysis indicators and signals</p>
                <div class="tool-form" id="technical">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="technicalCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Timeframe:</label>
                        <select id="timeframe">
                            <option value="1h">1 Hour</option>
                            <option value="4h">4 Hours</option>
                            <option value="1d">1 Day</option>
                            <option value="1w">1 Week</option>
                        </select>
                    </div>
                    <button class="btn" onclick="analyzeTechnical()">Analyze</button>
                    <div class="result" id="technicalResult"></div>
                </div>
            </div>

            <!-- Trading Simulator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="trading">
                    <span class="tool-icon">üéÆ</span>
                    <h3 class="tool-title">Trading Simulator</h3>
                </div>
                <p class="tool-description">Practice trading with virtual money</p>
                <div class="tool-form" id="trading">
                    <div class="form-group">
                        <label>Virtual Balance (USD):</label>
                        <input type="number" id="virtualBalance" placeholder="10000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="tradingCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Trade Type:</label>
                        <select id="tradeType">
                            <option value="buy">Buy</option>
                            <option value="sell">Sell</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Amount (USD):</label>
                        <input type="number" id="tradeAmount" placeholder="1000" step="any">
                    </div>
                    <button class="btn" onclick="simulateTrade()">Execute Trade</button>
                    <div class="result" id="tradingResult"></div>
                </div>
            </div>

            <!-- Mining Calculator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="mining">
                    <span class="tool-icon">‚õèÔ∏è</span>
                    <h3 class="tool-title">Mining Calculator</h3>
                </div>
                <p class="tool-description">Calculate mining profitability and returns</p>
                <div class="tool-form" id="mining">
                    <div class="form-group">
                        <label>Hash Rate (MH/s):</label>
                        <input type="number" id="hashRate" placeholder="100" step="any">
                    </div>
                    <div class="form-group">
                        <label>Power Consumption (W):</label>
                        <input type="number" id="powerConsumption" placeholder="3000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Electricity Cost ($/kWh):</label>
                        <input type="number" id="electricityCost" placeholder="0.12" step="any">
                    </div>
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="miningCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="calculateMining()">Calculate Profitability</button>
                    <div class="result" id="miningResult"></div>
                </div>
            </div>

            <!-- Paper Wallet Generator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="paperwallet">
                    <span class="tool-icon">üìÑ</span>
                    <h3 class="tool-title">Paper Wallet Generator</h3>
                </div>
                <p class="tool-description">Generate secure paper wallets for offline storage</p>
                <div class="tool-form" id="paperwallet">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="walletCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="litecoin">Litecoin (LTC)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Number of Wallets:</label>
                        <input type="number" id="walletCount" placeholder="1" min="1" max="10">
                    </div>
                    <button class="btn" onclick="generateWallet()">Generate Wallet</button>
                    <div class="result" id="paperwalletResult"></div>
                </div>
            </div>
        </div>

            <!-- Technical Analysis -->
            <div class="tool-card">
                <div class="tool-header" data-tool="technical">
                    <span class="tool-icon">üìà</span>
                    <h3 class="tool-title">Technical Analysis</h3>
                </div>
                <p class="tool-description">Advanced technical analysis indicators and signals</p>
                <div class="tool-form" id="technical">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="technicalCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Timeframe:</label>
                        <select id="timeframe">
                            <option value="1h">1 Hour</option>
                            <option value="4h">4 Hours</option>
                            <option value="1d">1 Day</option>
                            <option value="1w">1 Week</option>
                        </select>
                    </div>
                    <button class="btn" onclick="analyzeTechnical()">Analyze</button>
                    <div class="result" id="technicalResult"></div>
                </div>
            </div>

            <!-- Trading Simulator -->
            <div class="tool-card">
                <div class="tool-header" data-tool="trading">
                    <span class="tool-icon">üéÆ</span>
                    <h3 class="tool-title">Trading Simulator</h3>
                </div>
                <p class="tool-description">Practice trading with virtual money</p>
                <div class="tool-form" id="trading">
                    <div class="form-group">
                        <label>Virtual Balance (USD):</label>
                        <input type="number" id="virtualBalance" placeholder="10000" step="any">
                    </div>
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="tradingCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                        </select>
                    </div>
                    <div class="form<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apps Hub - CryptoTools Pro</title>

</head>
<body>
    <header>
        <nav class="container">
            <a href="../index.html" class="logo">üöÄ CryptoTools Pro</a>
            <ul class="nav-menu">
                <li><a href="../index.html">Home</a></li>
                <li><a href="index.html">Tools</a></li>
                <li><a href="../news/">News</a></li>
                <li><a href="../guides/">Guides</a></li>
            </ul>
        </nav>
    </header>

    <main class="container">
        <a href="../index.html" class="back-btn">‚Üê Back to Home</a>
        
        <div class="page-title">
            <h1>Professional Crypto Tools</h1>
            <p>Complete suite of calculators, converters and analysis tools</p>
        </div>

        <!-- Price Ticker -->
        <div class="price-ticker">
            <div class="ticker-content" id="priceTicker">
                <!-- Loaded dynamically -->
            </div>
        </div>

        <div class="tools-grid">
            <!-- Converter Tool -->
            <div class="tool-card">
                <div class="tool-header" data-tool="converter">
                    <span class="tool-icon">üîÑ</span>
                    <h3 class="tool-title">Crypto Converter</h3>
                </div>
                <p class="tool-description">Convert between different cryptocurrencies and fiat currencies with real-time rates</p>
                <div class="tool-form" id="converter">
                    <div class="form-group">
                        <label>From Currency:</label>
                        <select id="fromCurrency">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                            <option value="solana">Solana (SOL)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>To Currency:</label>
                        <select id="toCurrency">
                            <option value="usd">USD</option>
                            <option value="eur">EUR</option>
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Amount:</label>
                        <input type="number" id="convertAmount" placeholder="Enter amount" step="any">
                    </div>
                    <button class="btn" onclick="convertCurrency()">Convert</button>
                    <div class="result" id="convertResult"></div>
                </div>
            </div>

            <!-- Portfolio Tracker -->
            <div class="tool-card">
                <div class="tool-header" data-tool="portfolio">
                    <span class="tool-icon">üìä</span>
                    <h3 class="tool-title">Portfolio Tracker</h3>
                </div>
                <p class="tool-description">Track your cryptocurrency portfolio value and performance</p>
                <div class="tool-form" id="portfolio">
                    <div class="form-group">
                        <label>Cryptocurrency:</label>
                        <select id="portfolioCoin">
                            <option value="bitcoin">Bitcoin (BTC)</option>
                            <option value="ethereum">Ethereum (ETH)</option>
                            <option value="cardano">Cardano (ADA)</option>
                            <option value="solana">Solana (SOL)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Amount Held:</label>
                        <input type="number" id="portfolioAmount" placeholder="0.0" step="any">
                    </div>
                    <div class="form-group">
                        <label>Purchase Price (USD):</label>
                        <input type="number" id="purchasePrice" placeholder="0.0" step="any">
                    </div>
                    <button class="btn" onclick="calculatePortfolio()">Calculate Portfolio</button>
                    <div class="result" id="portfolioResult"></div>
                </div>
            </div>
    <script>
        // Global variables
        let cryptoData = {};
        let currentTool = null;

        // Mock data for demo (bypasses CORS issues)
        const mockCryptoData = {
            bitcoin: { 
                usd: 45230.50, eur: 41850.30, gbp: 36420.80, jpy: 6785430.20,
                usd_24h_change: 2.45, market_cap: 890000000000 
            },
            ethereum: { 
                usd: 2580.75, eur: 2385.60, gbp: 2076.40, jpy: 387650.90,
                usd_24h_change: -1.23, market_cap: 310000000000 
            },
            cardano: { 
                usd: 0.4520, eur: 0.4180, gbp: 0.3640, jpy: 67.85,
                usd_24h_change: 5.67, market_cap: 15800000000 
            },
            solana: { 
                usd: 98.75, eur: 91.30, gbp: 79.60, jpy: 14825.50,
                usd_24h_change: 3.21, market_cap: 45600000000 
            },
            polkadot: { 
                usd: 6.85, eur: 6.33, gbp: 5.51, jpy: 1028.75,
                usd_24h_change: -0.89, market_cap: 8900000000 
            },
            chainlink: { 
                usd: 14.25, eur: 13.18, gbp: 11.48, jpy: 2140.50,
                usd_24h_change: 1.75, market_cap: 8200000000 
            },
            litecoin: { 
                usd: 68.90, eur: 63.70, gbp: 55.50, jpy: 10350.60,
                usd_24h_change: 0.95, market_cap: 5100000000 
            },
            polygon: { 
                usd: 0.7890, eur: 0.7300, gbp: 0.6360, jpy: 118.50,
                usd_24h_change: 4.32, market_cap: 7800000000 
            }
        };

        // API Functions with fallback to mock data
        async function fetchCryptoData(coins = 'bitcoin,ethereum,cardano,solana') {
            try {
                // Try real API first
                const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coins}&vs_currencies=usd,eur,gbp,jpy&include_24hr_change=true&include_market_cap=true`);
                
                if (!response.ok) throw new Error('API request failed');
                
                const data = await response.json();
                cryptoData = data;
                return data;
            } catch (error) {
                console.log('Using mock data due to API limitations');
                // Use mock data as fallback
                const requestedCoins = coins.split(',');
                const filteredData = {};
                requestedCoins.forEach(coin => {
                    if (mockCryptoData[coin]) {
                        filteredData[coin] = mockCryptoData[coin];
                    }
                });
                cryptoData = filteredData;
                return filteredData;
            }
        }

        async function fetchHistoricalData(coinId, days = 30) {
            try {
                const response = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`);
                if (!response.ok) throw new Error('API request failed');
                const data = await response.json();
                return data;
            } catch (error) {
                console.log('Historical data not available, using mock data');
                return null;
            }
        }

        // Tool functions
        function toggleTool(toolId, event) {
			if (event) {
				event.stopPropagation();
			}
    
		const allTools = document.querySelectorAll('.tool-form');
		const targetTool = document.getElementById(toolId);
    
		if (currentTool === toolId) {
			targetTool.classList.remove('active');
			currentTool = null;
		} else {
			allTools.forEach(tool => tool.classList.remove('active'));
			targetTool.classList.add('active');
			currentTool = toolId;
		}
	}
	window.toggleTool = toggleTool;

        async function convertCurrency() {
            const fromCurrency = document.getElementById('fromCurrency').value;
            const toCurrency = document.getElementById('toCurrency').value;
            const amount = parseFloat(document.getElementById('convertAmount').value);
            
            if (!amount || amount <= 0) {
                showResult('convertResult', 'Please enter a valid amount', 'error');
                return;
            }

            showResult('convertResult', 'Calculating...', 'loading');

            try {
                const data = await fetchCryptoData(`${fromCurrency},${toCurrency}`);
                
                let fromPrice = 1, toPrice = 1;
                
                if (data[fromCurrency]) {
                    fromPrice = data[fromCurrency].usd;
                }
                
                if (data[toCurrency]) {
                    toPrice = 1 / data[toCurrency].usd;
                } else {
                    // Handle fiat currencies
                    const rates = { usd: 1, eur: 0.92, gbp: 0.79, jpy: 150 };
                    toPrice = rates[toCurrency] || 1;
                }
                
                const result = (amount * fromPrice * toPrice).toFixed(8);
                const currentRate = (fromPrice * toPrice).toFixed(8);
                
                showResult('convertResult', `
                    <strong>Conversion Result:</strong><br>
                    ${amount} ${fromCurrency.toUpperCase()} = ${result} ${toCurrency.toUpperCase()}<br>
                    Exchange Rate: 1 ${fromCurrency.toUpperCase()} = ${currentRate} ${toCurrency.toUpperCase()}<br>
                    Updated: ${new Date().toLocaleTimeString()}
                `);
                
            } catch (error) {
                showResult('convertResult', 'Error converting currency. Please try again.', 'error');
            }
        }

        async function calculatePortfolio() {
            const coin = document.getElementById('portfolioCoin').value;
            const amount = parseFloat(document.getElementById('portfolioAmount').value);
            const purchasePrice = parseFloat(document.getElementById('purchasePrice').value);
            
            if (!amount || !purchasePrice || amount <= 0 || purchasePrice <= 0) {
                showResult('portfolioResult', 'Please enter valid amounts', 'error');
                return;
            }

            showResult('portfolioResult', 'Loading...', 'loading');

            try {
                const data = await fetchCryptoData(coin);
                const currentPrice = data[coin].usd;
                const currentValue = amount * currentPrice;
                const initialValue = amount * purchasePrice;
                const profit = currentValue - initialValue;
                const profitPercentage = ((profit / initialValue) * 100).toFixed(2);
                
                const result = `
                    <strong>Portfolio Analysis:</strong><br>
                    Current Value: ${currentValue.toFixed(2)}<br>
                    Initial Investment: ${initialValue.toFixed(2)}<br>
                    Profit/Loss: ${profit.toFixed(2)} (${profitPercentage}%)<br>
                    Current Price: ${currentPrice.toFixed(2)}
                `;
                
                showResult('portfolioResult', result);
                
            } catch (error) {
                showResult('portfolioResult', 'Error calculating portfolio', 'error');
            }
        }

        async function calculateDCA() {
    const coin = document.getElementById('dcaCoin').value;
    const amount = parseFloat(document.getElementById('dcaAmount').value);
    const frequency = document.getElementById('dcaFrequency').value;
    const period = parseInt(document.getElementById('dcaPeriod').value);
    
    if (!amount || !period || amount <= 0 || period <= 0) {
        showResult('dcaResult', 'Please enter valid values', 'error');
        return;
    }

    showResult('dcaResult', 'Loading real historical data...', 'loading');

    try {
        // Obtener precio actual
        const currentData = await fetchCryptoData(coin);
        const currentPrice = currentData[coin].usd;
        
        // Calcular d√≠as hacia atr√°s seg√∫n el per√≠odo
        const daysBack = period * 30;
        const endDate = Math.floor(Date.now() / 1000);
        const startDate = endDate - (daysBack * 24 * 60 * 60);
        
        // Obtener datos hist√≥ricos de CoinGecko
        const historicalResponse = await fetch(
            `https://api.coingecko.com/api/v3/coins/${coin}/market_chart/range?vs_currency=usd&from=${startDate}&to=${endDate}`
        );
        const historicalData = await historicalResponse.json();
        
        if (!historicalData.prices || historicalData.prices.length === 0) {
            throw new Error('No historical data available');
        }
        
        // Procesar datos seg√∫n la frecuencia
        const purchases = [];
        let totalInvestment = 0;
        let totalCoins = 0;
        let purchaseCount = 0;
        
        // Determinar intervalo de compras en d√≠as
        let intervalDays;
        switch(frequency) {
            case 'daily':
                intervalDays = 1;
                break;
            case 'weekly':
                intervalDays = 7;
                break;
            case 'monthly':
                intervalDays = 30;
                break;
        }
        
        // Simular compras DCA con precios hist√≥ricos reales
        const startTime = historicalData.prices[0][0];
        const endTime = historicalData.prices[historicalData.prices.length - 1][0];
        
        for (let time = startTime; time <= endTime; time += intervalDays * 24 * 60 * 60 * 1000) {
            // Encontrar el precio m√°s cercano a esta fecha
            const closestPrice = historicalData.prices.find(price => 
                Math.abs(price[0] - time) <= (intervalDays * 24 * 60 * 60 * 1000 / 2)
            );
            
            if (closestPrice && purchaseCount < (period * (frequency === 'daily' ? 30 : frequency === 'weekly' ? 4 : 1))) {
                const purchasePrice = closestPrice[1];
                const coinsAcquired = amount / purchasePrice;
                
                purchases.push({
                    date: new Date(time),
                    price: purchasePrice,
                    amount: amount,
                    coins: coinsAcquired
                });
                
                totalInvestment += amount;
                totalCoins += coinsAcquired;
                purchaseCount++;
            }
        }
        
        // Calcular m√©tricas
        const avgPrice = totalInvestment / totalCoins;
        const currentValue = totalCoins * currentPrice;
        const profit = currentValue - totalInvestment;
        const roi = ((profit / totalInvestment) * 100);
        
        // Formatear resultado
        const result = `
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 10px;">
                <strong style="color: #2c3e50; font-size: 16px;">üìä DCA Strategy Results:</strong><br><br>
                <div style="display: grid; gap: 8px;">
                    <div><strong>Total Investment:</strong> $${totalInvestment.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                    <div><strong>Total Coins Acquired:</strong> ${totalCoins.toFixed(6)}</div>
                    <div style="color: ${currentValue > totalInvestment ? '#27ae60' : '#e74c3c'};">
                        <strong>Current Value:</strong> $${currentValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                    </div>
                    <div style="color: ${profit > 0 ? '#27ae60' : '#e74c3c'}; font-size: 16px;">
                        <strong>Profit/Loss:</strong> ${profit > 0 ? '+' : ''}$${profit.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})} (${roi > 0 ? '+' : ''}${roi.toFixed(2)}%)
                    </div>
                    <div><strong>Average Buy Price:</strong> $${avgPrice.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                    <div><strong>Current ${coin.toUpperCase()} Price:</strong> $${currentPrice.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                    <div><strong>Total Purchases:</strong> ${purchaseCount}</div>
                </div>
            </div>
        `;
        
        showResult('dcaResult', result);
        
    } catch (error) {
        console.error('DCA Calculation Error:', error);
        showResult('dcaResult', `Error calculating DCA: ${error.message}. Please try again.`, 'error');
    }
}

// Funci√≥n auxiliar mejorada para obtener datos de crypto (si no la tienes)
async function fetchCryptoData(coin) {
    try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coin}&vs_currencies=usd&include_24hr_change=true`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (!data[coin]) {
            throw new Error(`Data not found for ${coin}`);
        }
        return data;
    } catch (error) {
        console.error('Error fetching crypto data:', error);
        throw error;
    }
}

        async function calculateBitcoin() {
    const btcAmount = parseFloat(document.getElementById('btcAmount').value);
    const currency = document.getElementById('btcCurrency').value;
    
    if (!btcAmount || btcAmount <= 0) {
        showResult('bitcoinResult', 'Please enter a valid Bitcoin amount', 'error');
        return;
    }

    showResult('bitcoinResult', 'Fetching real-time Bitcoin data...', 'loading');

    try {
        // Obtener datos completos de Bitcoin incluyendo market cap y volumen
        const response = await fetch(
            `https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=${currency}&include_24hr_change=true&include_24hr_vol=true&include_market_cap=true&include_last_updated_at=true`
        );
        
        if (!response.ok) {
            throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.bitcoin || !data.bitcoin[currency]) {
            throw new Error(`Price data not available for ${currency.toUpperCase()}`);
        }
        
        const price = data.bitcoin[currency];
        const change24h = data.bitcoin[`${currency}_24h_change`] || 0;
        const volume24h = data.bitcoin[`${currency}_24h_vol`] || 0;
        const marketCap = data.bitcoin[`${currency}_market_cap`] || 0;
        const lastUpdated = data.bitcoin.last_updated_at;
        const totalValue = btcAmount * price;
        
        // Determinar formato de n√∫meros seg√∫n la divisa
        const getNumberFormat = (value, currency) => {
            const options = {
                minimumFractionDigits: 2,
                maximumFractionDigits: currency === 'jpy' ? 0 : 2
            };
            return value.toLocaleString('en-US', options);
        };
        
        // Determinar s√≠mbolo de divisa
        const getCurrencySymbol = (curr) => {
            const symbols = {
                'usd': '$',
                'eur': '‚Ç¨',
                'gbp': '¬£',
                'jpy': '¬•'
            };
            return symbols[curr] || curr.toUpperCase();
        };
        
        const currencySymbol = getCurrencySymbol(currency);
        const currencyCode = currency.toUpperCase();
        
        // Calcular algunos datos adicionales √∫tiles
        const btcInSatoshis = btcAmount * 100000000;
        const priceChange24h = price * (change24h / 100);
        
        const result = `
            <div style="background: linear-gradient(135deg, #f39c12, #e67e22); padding: 20px; border-radius: 12px; color: white; margin-top: 10px;">
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 24px; margin-right: 10px;">‚Çø</span>
                    <strong style="font-size: 18px;">Bitcoin Calculator Results</strong>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="font-size: 20px; font-weight: bold; margin-bottom: 10px;">
                        ${btcAmount} BTC = ${currencySymbol}${getNumberFormat(totalValue, currency)} ${currencyCode}
                    </div>
                    <div style="font-size: 14px; opacity: 0.9;">
                        ‚âà ${btcInSatoshis.toLocaleString()} Satoshis
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <div style="font-size: 12px; opacity: 0.8;">Current BTC Price</div>
                        <div style="font-weight: bold;">${currencySymbol}${getNumberFormat(price, currency)}</div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <div style="font-size: 12px; opacity: 0.8;">24h Change</div>
                        <div style="color: ${change24h >= 0 ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">
                            ${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}%
                        </div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <div style="font-size: 12px; opacity: 0.8;">24h Volume</div>
                        <div style="font-size: 13px; font-weight: bold;">
                            ${currencySymbol}${(volume24h / 1000000000).toFixed(2)}B
                        </div>
                    </div>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px;">
                        <div style="font-size: 12px; opacity: 0.8;">Market Cap Rank</div>
                        <div style="font-weight: bold;">#1</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                    <div style="font-size: 12px; opacity: 0.8; margin-bottom: 5px;">Price Change (24h)</div>
                    <div style="color: ${change24h >= 0 ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">
                        ${change24h >= 0 ? '+' : ''}${currencySymbol}${getNumberFormat(Math.abs(priceChange24h), currency)}
                    </div>
                </div>
                
                <div style="font-size: 11px; opacity: 0.7; text-align: center; margin-top: 10px;">
                    Last updated: ${new Date(lastUpdated * 1000).toLocaleString()}
                </div>
            </div>
        `;
        
        showResult('bitcoinResult', result);
        
    } catch (error) {
        console.error('Bitcoin Calculator Error:', error);
        
        let errorMessage = 'Error calculating Bitcoin value';
        if (error.message.includes('API Error')) {
            errorMessage = 'API service temporarily unavailable. Please try again.';
        } else if (error.message.includes('Price data not available')) {
            errorMessage = error.message;
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage = 'Network error. Please check your connection and try again.';
        }
        
        showResult('bitcoinResult', errorMessage, 'error');
    }
}

async function compareExchanges() {
    const coin = document.getElementById('exchangeCoin').value;
    const amount = parseFloat(document.getElementById('exchangeAmount').value);
    
    if (!amount || amount <= 0) {
        showResult('exchangeResult', 'Please enter a valid amount', 'error');
        return;
    }

    showResult('exchangeResult', 'Fetching real-time data from multiple exchanges...', 'loading');

    try {
        // Lista de exchanges reales con sus APIs
        const exchangePromises = await Promise.allSettled([
            // CoinGecko como referencia base
            fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coin}&vs_currencies=usd&include_24hr_change=true`)
                .then(res => res.json())
                .then(data => ({
                    name: 'CoinGecko',
                    price: data[coin]?.usd,
                    change24h: data[coin]?.usd_24h_change,
                    status: 'success',
                    type: 'aggregator'
                })),

            // Binance API
            fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${getCoinSymbol(coin)}USDT`)
                .then(res => res.json())
                .then(data => ({
                    name: 'Binance',
                    price: parseFloat(data.lastPrice),
                    change24h: parseFloat(data.priceChangePercent),
                    volume24h: parseFloat(data.volume),
                    status: 'success',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'Binance', status: 'error', type: 'exchange' })),

            // Coinbase API
            fetch(`https://api.coinbase.com/v2/exchange-rates?currency=${getCoinSymbol(coin)}`)
                .then(res => res.json())
                .then(data => ({
                    name: 'Coinbase',
                    price: parseFloat(data.data?.rates?.USD),
                    status: 'success',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'Coinbase', status: 'error', type: 'exchange' })),

            // Kraken API (usando ticker p√∫blico)
            fetch(`https://api.kraken.com/0/public/Ticker?pair=${getKrakenPair(coin)}`)
                .then(res => res.json())
                .then(data => {
                    const pairKey = Object.keys(data.result || {})[0];
                    const tickerData = data.result?.[pairKey];
                    return {
                        name: 'Kraken',
                        price: tickerData ? parseFloat(tickerData.c[0]) : null,
                        status: tickerData ? 'success' : 'error',
                        type: 'exchange'
                    };
                })
                .catch(() => ({ name: 'Kraken', status: 'error', type: 'exchange' })),

            // KuCoin API
            fetch(`https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=${getCoinSymbol(coin)}-USDT`)
                .then(res => res.json())
                .then(data => ({
                    name: 'KuCoin',
                    price: data.data ? parseFloat(data.data.price) : null,
                    status: data.data ? 'success' : 'error',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'KuCoin', status: 'error', type: 'exchange' })),

            // Huobi Global API
            fetch(`https://api.huobi.pro/market/detail/merged?symbol=${getCoinSymbol(coin).toLowerCase()}usdt`)
                .then(res => res.json())
                .then(data => ({
                    name: 'Huobi Global',
                    price: data.tick ? parseFloat(data.tick.close) : null,
                    status: data.tick ? 'success' : 'error',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'Huobi Global', status: 'error', type: 'exchange' })),

            // Gate.io API
            fetch(`https://api.gateio.ws/api/v4/spot/tickers?currency_pair=${getCoinSymbol(coin)}_USDT`)
                .then(res => res.json())
                .then(data => ({
                    name: 'Gate.io',
                    price: data[0] ? parseFloat(data[0].last) : null,
                    status: data[0] ? 'success' : 'error',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'Gate.io', status: 'error', type: 'exchange' })),

            // OKX API
            fetch(`https://www.okx.com/api/v5/market/ticker?instId=${getCoinSymbol(coin)}-USDT`)
                .then(res => res.json())
                .then(data => ({
                    name: 'OKX',
                    price: data.data?.[0] ? parseFloat(data.data[0].last) : null,
                    status: data.data?.[0] ? 'success' : 'error',
                    type: 'exchange'
                }))
                .catch(() => ({ name: 'OKX', status: 'error', type: 'exchange' }))
        ]);

        // Procesar resultados
        const exchanges = exchangePromises
            .map(result => result.status === 'fulfilled' ? result.value : result.reason)
            .filter(exchange => exchange.status === 'success' && exchange.price > 0);

        if (exchanges.length === 0) {
            throw new Error('No exchange data available at the moment');
        }

        // Ordenar por precio (mayor a menor)
        exchanges.sort((a, b) => b.price - a.price);

        // Calcular estad√≠sticas
        const prices = exchanges.map(e => e.price);
        const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
        const highestPrice = Math.max(...prices);
        const lowestPrice = Math.min(...prices);
        const priceSpread = ((highestPrice - lowestPrice) / lowestPrice * 100);

        // Generar resultado HTML
        let result = `
            <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-top: 10px;">
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 20px; margin-right: 10px;">‚öñÔ∏è</span>
                    <strong style="font-size: 18px; color: #2c3e50;">Exchange Comparison for ${amount} ${coin.toUpperCase()}</strong>
                </div>
                
                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #3498db;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; text-align: center;">
                        <div>
                            <div style="font-size: 12px; color: #7f8c8d;">Average Price</div>
                            <div style="font-weight: bold; color: #34495e;">$${avgPrice.toFixed(2)}</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #7f8c8d;">Price Spread</div>
                            <div style="font-weight: bold; color: #e74c3c;">${priceSpread.toFixed(2)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #7f8c8d;">Exchanges</div>
                            <div style="font-weight: bold; color: #27ae60;">${exchanges.length} Active</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
        `;

        exchanges.forEach((exchange, index) => {
            const value = amount * exchange.price;
            const isHighest = exchange.price === highestPrice;
            const isLowest = exchange.price === lowestPrice;
            const diffFromAvg = ((exchange.price - avgPrice) / avgPrice * 100);
            
            let badge = '';
            let cardColor = 'white';
            
            if (isHighest) {
                badge = ' ü•á Best Price';
                cardColor = '#e8f5e8';
            } else if (isLowest) {
                badge = ' üí∞ Lowest Price';
                cardColor = '#ffe8e8';
            }
            
            result += `
                <div style="background: ${cardColor}; padding: 12px; border-radius: 8px; margin-bottom: 8px; border-left: 3px solid ${isHighest ? '#27ae60' : isLowest ? '#e74c3c' : '#bdc3c7'};">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong style="color: #2c3e50;">${exchange.name}${badge}</strong>
                            <div style="font-size: 14px; color: #7f8c8d;">
                                $${exchange.price.toFixed(2)} per ${coin.toUpperCase()}
                                ${diffFromAvg !== 0 ? `<span style="color: ${diffFromAvg > 0 ? '#27ae60' : '#e74c3c'};">(${diffFromAvg > 0 ? '+' : ''}${diffFromAvg.toFixed(2)}%)</span>` : ''}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 16px; font-weight: bold; color: #2c3e50;">
                                $${value.toFixed(2)}
                            </div>
                            <div style="font-size: 12px; color: #95a5a6;">
                                ${exchange.type === 'exchange' ? 'Direct' : 'Aggregated'}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        });

        const potentialSavings = (highestPrice - lowestPrice) * amount;
        
        result += `
                </div>
                
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 14px; margin-bottom: 5px;">üí° Potential Savings</div>
                    <div style="font-size: 18px; font-weight: bold;">
                        Up to $${potentialSavings.toFixed(2)} by choosing the right exchange
                    </div>
                </div>
                
                <div style="font-size: 11px; color: #95a5a6; text-align: center; margin-top: 10px;">
                    ‚ö†Ô∏è Prices are real-time but may not include trading fees. Always check exchange fees before trading.
                </div>
            </div>
        `;

        showResult('exchangeResult', result);

    } catch (error) {
        console.error('Exchange Comparison Error:', error);
        showResult('exchangeResult', `Error fetching exchange data: ${error.message}. Please try again.`, 'error');
    }
}

// Funciones auxiliares para mapear s√≠mbolos de monedas seg√∫n cada exchange
function getCoinSymbol(coin) {
    const symbols = {
        'bitcoin': 'BTC',
        'ethereum': 'ETH',
        'cardano': 'ADA',
        'solana': 'SOL'
    };
    return symbols[coin] || coin.toUpperCase();
}

function getKrakenPair(coin) {
    const pairs = {
        'bitcoin': 'XBTUSD',
        'ethereum': 'ETHUSD',
        'cardano': 'ADAUSD'
    };
    return pairs[coin] || `${getCoinSymbol(coin)}USD`;
}

// Price Alerts System - Professional Version
let alertCheckInterval = null;
const ALERT_STORAGE_KEY = 'cryptoToolsAlerts';
const ALERT_CHECK_INTERVAL = 60000; // Check every minute

async function setAlert() {
    const coin = document.getElementById('alertCoin').value;
    const targetPrice = parseFloat(document.getElementById('targetPrice').value);
    const alertType = document.getElementById('alertType').value;
    
    if (!targetPrice || targetPrice <= 0) {
        showResult('alertResult', 'Please enter a valid target price', 'error');
        return;
    }

    showResult('alertResult', 'Setting up price alert...', 'loading');

    try {
        // Get current price to validate alert
        const currentData = await fetchCryptoData(coin);
        const currentPrice = currentData[coin].usd;
        
        // Validate alert logic
        const isValidAlert = validateAlert(currentPrice, targetPrice, alertType);
        if (!isValidAlert.valid) {
            showResult('alertResult', isValidAlert.message, 'error');
            return;
        }

        // Create alert object
        const alert = {
            id: generateAlertId(),
            coin: coin,
            coinName: getCoinDisplayName(coin),
            targetPrice: targetPrice,
            currentPrice: currentPrice,
            alertType: alertType,
            createdAt: new Date().toISOString(),
            isActive: true,
            triggered: false
        };

        // Save alert
        saveAlert(alert);
        
        // Start monitoring if not already running
        startAlertMonitoring();
        
        // Show success message
        const result = `
            <div style="background: linear-gradient(135deg, #27ae60, #2ecc71); color: white; padding: 20px; border-radius: 12px; margin-top: 10px;">
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 24px; margin-right: 10px;">üîî</span>
                    <strong style="font-size: 18px;">Alert Set Successfully!</strong>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: grid; gap: 8px;">
                        <div><strong>Cryptocurrency:</strong> ${alert.coinName} (${coin.toUpperCase()})</div>
                        <div><strong>Target Price:</strong> $${targetPrice.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        <div><strong>Current Price:</strong> $${currentPrice.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</div>
                        <div><strong>Alert Type:</strong> ${alertType === 'above' ? 'When price goes ABOVE target' : 'When price goes BELOW target'}</div>
                        <div><strong>Status:</strong> <span style="color: #2ecc71;">‚óè</span> Active</div>
                        <div><strong>Alert ID:</strong> #${alert.id}</div>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                    <div style="font-size: 14px; margin-bottom: 5px;"><strong>Price Movement Needed:</strong></div>
                    <div style="font-size: 16px;">
                        ${alertType === 'above' 
                            ? `+$${(targetPrice - currentPrice).toFixed(2)} (+${(((targetPrice - currentPrice) / currentPrice) * 100).toFixed(2)}%)`
                            : `-$${(currentPrice - targetPrice).toFixed(2)} (-${(((currentPrice - targetPrice) / currentPrice) * 100).toFixed(2)}%)`
                        }
                    </div>
                </div>
                
                <div style="font-size: 13px; opacity: 0.9; text-align: center;">
                    üîÑ Checking price every minute ‚Ä¢ üíæ Stored locally on your device
                </div>
                
                <div style="margin-top: 15px; text-align: center;">
                    <button onclick="showActiveAlerts()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                        View All Active Alerts
                    </button>
                </div>
            </div>
        `;
        
        showResult('alertResult', result);
        
    } catch (error) {
        console.error('Price Alert Error:', error);
        showResult('alertResult', `Error setting price alert: ${error.message}. Please try again.`, 'error');
    }
}

// Validate alert logic
function validateAlert(currentPrice, targetPrice, alertType) {
    if (alertType === 'above' && targetPrice <= currentPrice) {
        return {
            valid: false,
            message: `Target price ($${targetPrice.toFixed(2)}) must be ABOVE current price ($${currentPrice.toFixed(2)}) for "above" alerts.`
        };
    }
    
    if (alertType === 'below' && targetPrice >= currentPrice) {
        return {
            valid: false,
            message: `Target price ($${targetPrice.toFixed(2)}) must be BELOW current price ($${currentPrice.toFixed(2)}) for "below" alerts.`
        };
    }
    
    return { valid: true };
}

// Generate unique alert ID
function generateAlertId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Get display name for coins
function getCoinDisplayName(coin) {
    const names = {
        'bitcoin': 'Bitcoin',
        'ethereum': 'Ethereum',
        'cardano': 'Cardano',
        'solana': 'Solana'
    };
    return names[coin] || coin.charAt(0).toUpperCase() + coin.slice(1);
}

// Save alert to local storage
function saveAlert(alert) {
    const alerts = getStoredAlerts();
    alerts.push(alert);
    try {
        const alertsData = JSON.stringify(alerts);
        // Using in-memory storage as localStorage is not available
        window.cryptoAlertsStorage = alertsData;
    } catch (error) {
        console.error('Error saving alert:', error);
        throw new Error('Failed to save alert. Storage may be full.');
    }
}

// Get stored alerts
function getStoredAlerts() {
    try {
        const stored = window.cryptoAlertsStorage || '[]';
        return JSON.parse(stored).filter(alert => alert.isActive && !alert.triggered);
    } catch (error) {
        console.error('Error reading alerts:', error);
        return [];
    }
}

// Update stored alerts
function updateStoredAlerts(alerts) {
    try {
        window.cryptoAlertsStorage = JSON.stringify(alerts);
    } catch (error) {
        console.error('Error updating alerts:', error);
    }
}

// Start alert monitoring system
function startAlertMonitoring() {
    if (alertCheckInterval) {
        return; // Already running
    }
    
    console.log('üîî Starting price alert monitoring system...');
    
    alertCheckInterval = setInterval(async () => {
        await checkAllAlerts();
    }, ALERT_CHECK_INTERVAL);
    
    // Initial check
    setTimeout(() => checkAllAlerts(), 5000);
}

// Check all active alerts
async function checkAllAlerts() {
    const alerts = getStoredAlerts();
    
    if (alerts.length === 0) {
        // Stop monitoring if no active alerts
        if (alertCheckInterval) {
            clearInterval(alertCheckInterval);
            alertCheckInterval = null;
            console.log('üîî No active alerts. Stopping monitoring.');
        }
        return;
    }
    
    console.log(`üîî Checking ${alerts.length} active alerts...`);
    
    for (const alert of alerts) {
        try {
            const currentData = await fetchCryptoData(alert.coin);
            const currentPrice = currentData[alert.coin].usd;
            
            let shouldTrigger = false;
            
            if (alert.alertType === 'above' && currentPrice >= alert.targetPrice) {
                shouldTrigger = true;
            } else if (alert.alertType === 'below' && currentPrice <= alert.targetPrice) {
                shouldTrigger = true;
            }
            
            if (shouldTrigger) {
                triggerAlert(alert, currentPrice);
            }
            
        } catch (error) {
            console.error(`Error checking alert ${alert.id}:`, error);
        }
    }
}

// Trigger an alert
function triggerAlert(alert, currentPrice) {
    console.log(`üö® ALERT TRIGGERED: ${alert.coinName} ${alert.alertType} $${alert.targetPrice}`);
    
    // Mark alert as triggered
    const alerts = JSON.parse(window.cryptoAlertsStorage || '[]');
    const alertIndex = alerts.findIndex(a => a.id === alert.id);
    if (alertIndex !== -1) {
        alerts[alertIndex].triggered = true;
        alerts[alertIndex].triggeredAt = new Date().toISOString();
        alerts[alertIndex].triggeredPrice = currentPrice;
        updateStoredAlerts(alerts);
    }
    
    // Show browser notification if supported
    if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(`üö® Crypto Alert Triggered!`, {
            body: `${alert.coinName} is now ${alert.alertType} $${alert.targetPrice.toFixed(2)}! Current price: $${currentPrice.toFixed(2)}`,
            icon: '/favicon.ico'
        });
    }
    
    // Show visual alert on page
    showTriggeredAlert(alert, currentPrice);
}

// Show triggered alert visually
function showTriggeredAlert(alert, currentPrice) {
    const alertDiv = document.createElement('div');
    alertDiv.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #e74c3c, #c0392b);
        color: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(231, 76, 60, 0.3);
        z-index: 10000;
        max-width: 350px;
        animation: slideIn 0.5s ease-out;
    `;
    
    alertDiv.innerHTML = `
        <div style="display: flex; align-items: center; margin-bottom: 10px;">
            <span style="font-size: 20px; margin-right: 10px;">üö®</span>
            <strong>Price Alert Triggered!</strong>
        </div>
        <div style="margin-bottom: 15px;">
            <strong>${alert.coinName}</strong> has ${alert.alertType === 'above' ? 'risen above' : 'fallen below'} your target price!
        </div>
        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin-bottom: 15px;">
            <div>Target: $${alert.targetPrice.toFixed(2)}</div>
            <div>Current: $${currentPrice.toFixed(2)}</div>
            <div style="color: ${alert.alertType === 'above' ? '#2ecc71' : '#f39c12'};">
                ${alert.alertType === 'above' ? '+' : ''}${((currentPrice - alert.targetPrice) / alert.targetPrice * 100).toFixed(2)}%
            </div>
        </div>
        <button onclick="this.parentElement.remove()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer; width: 100%;">
            Dismiss
        </button>
    `;
    
    document.body.appendChild(alertDiv);
    
    // Auto remove after 10 seconds
    setTimeout(() => {
        if (alertDiv.parentElement) {
            alertDiv.remove();
        }
    }, 10000);
}

// Show all active alerts
function showActiveAlerts() {
    const alerts = getStoredAlerts();
    
    if (alerts.length === 0) {
        showResult('alertResult', `
            <div style="text-align: center; padding: 20px; color: #7f8c8d;">
                <span style="font-size: 48px;">üîî</span>
                <h3>No Active Alerts</h3>
                <p>Set your first price alert above!</p>
            </div>
        `);
        return;
    }
    
    let result = `
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-top: 10px;">
            <h3 style="margin: 0 0 15px 0; color: #2c3e50;">üìä Active Price Alerts (${alerts.length})</h3>
    `;
    
    alerts.forEach((alert, index) => {
        const timeSinceCreated = Math.round((Date.now() - new Date(alert.createdAt).getTime()) / (1000 * 60));
        
        result += `
            <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid #3498db;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong style="color: #2c3e50;">${alert.coinName}</strong>
                        <span style="background: #3498db; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; margin-left: 8px;">
                            ${alert.alertType.toUpperCase()}
                        </span>
                        <div style="font-size: 14px; color: #7f8c8d; margin-top: 4px;">
                            Target: $${alert.targetPrice.toFixed(2)} ‚Ä¢ Created ${timeSinceCreated}m ago
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #27ae60; font-weight: bold;">‚óè Active</div>
                        <button onclick="removeAlert('${alert.id}')" style="background: #e74c3c; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 12px; cursor: pointer; margin-top: 4px;">
                            Remove
                        </button>
                    </div>
                </div>
            </div>
        `;
    });
    
    result += `
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="clearAllAlerts()" style="background: #e74c3c; color: white; border: none; padding: 8px 15px; border-radius: 6px; cursor: pointer;">
                    Clear All Alerts
                </button>
            </div>
        </div>
    `;
    
    showResult('alertResult', result);
}

// Remove specific alert
function removeAlert(alertId) {
    const alerts = JSON.parse(window.cryptoAlertsStorage || '[]');
    const updatedAlerts = alerts.filter(alert => alert.id !== alertId);
    updateStoredAlerts(updatedAlerts);
    showActiveAlerts(); // Refresh the display
}

// Clear all alerts
function clearAllAlerts() {
    if (confirm('Are you sure you want to remove all active alerts?')) {
        window.cryptoAlertsStorage = '[]';
        if (alertCheckInterval) {
            clearInterval(alertCheckInterval);
            alertCheckInterval = null;
        }
        showResult('alertResult', `
            <div style="text-align: center; padding: 20px; color: #27ae60;">
                <span style="font-size: 48px;">‚úÖ</span>
                <h3>All Alerts Cleared</h3>
                <p>You can set new alerts anytime!</p>
            </div>
        `);
    }
}

// Request notification permission on page load
document.addEventListener('DOMContentLoaded', function() {
    if ('Notification' in window && Notification.permission !== 'granted' && Notification.permission !== 'denied') {
        Notification.requestPermission();
    }
});

// Fear & Greed Calculator - Professional Version with Real Data
async function calculateFearGreed() {
    showResult('feargreedResult', 'Analyzing real-time market sentiment data...', 'loading');

    try {
        // Fetch real Fear & Greed Index data and market metrics
        const [fearGreedData, marketData, dominanceData] = await Promise.all([
            fetchFearGreedIndex(),
            fetchMarketGlobalData(),
            fetchBitcoinDominance()
        ]);

        // Get user inputs (optional overrides)
        const userMarketCapChange = parseFloat(document.getElementById('marketCapChange').value);
        const userVolumeChange = parseFloat(document.getElementById('volumeChange').value);
        const userSocialMentions = parseInt(document.getElementById('socialMentions').value);

        // Use real data or user inputs if provided
        const marketCapChange = !isNaN(userMarketCapChange) ? userMarketCapChange : marketData.marketCapChangePercentage24h;
        const volumeChange = !isNaN(userVolumeChange) ? userVolumeChange : marketData.volumeChangePercentage24h;
        const socialScore = !isNaN(userSocialMentions) ? calculateSocialScore(userSocialMentions) : marketData.socialSentimentScore;

        // Calculate comprehensive Fear & Greed metrics
        const metrics = calculateAdvancedFearGreed({
            officialIndex: fearGreedData.value,
            marketCapChange: marketCapChange,
            volumeChange: volumeChange,
            socialScore: socialScore,
            bitcoinDominance: dominanceData.percentage,
            volatilityIndex: marketData.volatilityIndex,
            momentum: marketData.momentum
        });

        // Generate professional result display
        const result = generateFearGreedResult(metrics, fearGreedData, marketData);
        showResult('feargreedResult', result);

    } catch (error) {
        console.error('Fear & Greed Calculator Error:', error);
        showResult('feargreedResult', 'Error fetching market sentiment data. Please try again.', 'error');
    }
}

// Fetch real Fear & Greed Index from Alternative.me API
async function fetchFearGreedIndex() {
    try {
        const response = await fetch('https://api.alternative.me/fng/?limit=7');
        if (!response.ok) throw new Error('Fear & Greed API unavailable');
        
        const data = await response.json();
        const latest = data.data[0];
        const weekAgo = data.data[6] || data.data[data.data.length - 1];
        
        return {
            value: parseInt(latest.value),
            classification: latest.value_classification,
            timestamp: latest.timestamp,
            weekChange: parseInt(latest.value) - parseInt(weekAgo.value),
            historicalData: data.data
        };
    } catch (error) {
        // Fallback to calculated index if API fails
        console.warn('Using fallback Fear & Greed calculation');
        return {
            value: 50,
            classification: 'Neutral',
            timestamp: Date.now() / 1000,
            weekChange: 0,
            historicalData: [],
            fallback: true
        };
    }
}

// Fetch comprehensive market data
async function fetchMarketGlobalData() {
    try {
        const [globalResponse, btcResponse] = await Promise.all([
            fetch('https://api.coingecko.com/api/v3/global'),
            fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true')
        ]);

        const globalData = await globalResponse.json();
        const btcData = await btcResponse.json();
        
        const marketCap = globalData.data.total_market_cap.usd;
        const volume = globalData.data.total_volume.usd;
        const btcPrice = btcData.bitcoin.usd;
        const btcChange = btcData.bitcoin.usd_24h_change || 0;
        const btcVolume = btcData.bitcoin.usd_24h_vol || 0;

        return {
            marketCapChangePercentage24h: globalData.data.market_cap_change_percentage_24h_usd || 0,
            volumeChangePercentage24h: calculateVolumeChange(volume),
            socialSentimentScore: calculateSocialSentimentFromPrice(btcChange),
            volatilityIndex: Math.abs(btcChange),
            momentum: calculateMomentum(btcChange),
            marketCap: marketCap,
            volume: volume,
            btcPrice: btcPrice,
            btcDominance: globalData.data.market_cap_percentage.btc || 0
        };
    } catch (error) {
        throw new Error('Failed to fetch market data');
    }
}

// Fetch Bitcoin dominance data
async function fetchBitcoinDominance() {
    try {
        const response = await fetch('https://api.coingecko.com/api/v3/global');
        const data = await response.json();
        
        return {
            percentage: data.data.market_cap_percentage.btc || 50,
            change24h: 0 // Would need historical data for real calculation
        };
    } catch (error) {
        return { percentage: 50, change24h: 0 };
    }
}

// Calculate advanced Fear & Greed metrics
function calculateAdvancedFearGreed(data) {
    let score = data.officialIndex || 50;
    let components = {};

    // Market Cap Impact (Weight: 20%)
    const marketCapImpact = Math.min(Math.max(data.marketCapChange * 1.5, -15), 15);
    components.marketCap = {
        value: data.marketCapChange,
        impact: marketCapImpact,
        weight: 20
    };

    // Volume Impact (Weight: 15%)
    const volumeImpact = Math.min(Math.max(data.volumeChange * 1.2, -10), 10);
    components.volume = {
        value: data.volumeChange,
        impact: volumeImpact,
        weight: 15
    };

    // Social Sentiment (Weight: 15%)
    const socialImpact = Math.min(Math.max(data.socialScore, -10), 10);
    components.social = {
        value: data.socialScore,
        impact: socialImpact,
        weight: 15
    };

    // Bitcoin Dominance (Weight: 10%)
    const dominanceImpact = data.bitcoinDominance > 45 ? 5 : data.bitcoinDominance < 40 ? -5 : 0;
    components.dominance = {
        value: data.bitcoinDominance,
        impact: dominanceImpact,
        weight: 10
    };

    // Volatility Impact (Weight: 20%)
    const volatilityImpact = data.volatilityIndex > 10 ? -10 : data.volatilityIndex > 5 ? -5 : 5;
    components.volatility = {
        value: data.volatilityIndex,
        impact: volatilityImpact,
        weight: 20
    };

    // Momentum (Weight: 20%)
    const momentumImpact = data.momentum;
    components.momentum = {
        value: data.momentum,
        impact: momentumImpact,
        weight: 20
    };

    // If using fallback calculation (no official API)
    if (data.officialIndex === 50) {
        score = 50 + marketCapImpact + volumeImpact + socialImpact + dominanceImpact + volatilityImpact + momentumImpact;
    }

    score = Math.min(Math.max(score, 0), 100);

    return {
        score: Math.round(score),
        components: components,
        classification: getClassification(score),
        recommendation: getRecommendation(score),
        riskLevel: getRiskLevel(score)
    };
}

// Helper functions
function calculateVolumeChange(currentVolume) {
    // Simplified - in real app you'd compare with historical data
    return Math.random() * 20 - 10; // Placeholder
}

function calculateSocialSentimentFromPrice(priceChange) {
    return Math.min(Math.max(priceChange * 0.5, -10), 10);
}

function calculateSocialScore(mentions) {
    if (mentions < 500) return -5;
    if (mentions < 1000) return 0;
    if (mentions < 2000) return 5;
    return 10;
}

function calculateMomentum(priceChange) {
    return Math.min(Math.max(priceChange * 0.8, -15), 15);
}

function getClassification(score) {
    if (score <= 20) return 'Extreme Fear';
    if (score <= 40) return 'Fear';
    if (score <= 60) return 'Neutral';
    if (score <= 80) return 'Greed';
    return 'Extreme Greed';
}

function getRecommendation(score) {
    if (score <= 20) return 'Excellent buying opportunity - Market oversold';
    if (score <= 40) return 'Good time to accumulate - Cautious optimism';
    if (score <= 60) return 'Monitor closely - Balanced approach';
    if (score <= 80) return 'Consider taking partial profits - Market heated';
    return 'High risk - Consider reducing positions';
}

function getRiskLevel(score) {
    if (score <= 25) return { level: 'Low', color: '#27ae60' };
    if (score <= 45) return { level: 'Medium-Low', color: '#f39c12' };
    if (score <= 55) return { level: 'Medium', color: '#e67e22' };
    if (score <= 75) return { level: 'Medium-High', color: '#d35400' };
    return { level: 'High', color: '#e74c3c' };
}

// Generate comprehensive result display
function generateFearGreedResult(metrics, fearGreedData, marketData) {
    const { score, classification, recommendation, riskLevel, components } = metrics;
    
    // Get emoji and color
    const getEmoji = (score) => {
        if (score <= 20) return 'üò±';
        if (score <= 40) return 'üò®';
        if (score <= 60) return 'üòê';
        if (score <= 80) return 'üòä';
        return 'ü§ë';
    };
    
    const getColor = (score) => {
        if (score <= 20) return '#e74c3c';
        if (score <= 40) return '#e67e22';
        if (score <= 60) return '#f1c40f';
        if (score <= 80) return '#2ecc71';
        return '#27ae60';
    };

    return `
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 15px; margin-top: 10px;">
            <div style="text-align: center; margin-bottom: 20px;">
                <h2 style="margin: 0; font-size: 24px;">üìä Fear & Greed Index Analysis</h2>
            </div>
            
            <!-- Main Score Display -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 12px; text-align: center; margin-bottom: 20px;">
                <div style="font-size: 64px; margin: 10px 0;">${getEmoji(score)}</div>
                <div style="font-size: 48px; font-weight: bold; color: ${getColor(score)}; margin: 10px 0;">
                    ${score}/100
                </div>
                <div style="font-size: 24px; font-weight: bold; margin: 10px 0;">
                    ${classification}
                </div>
                ${fearGreedData.weekChange !== 0 ? `
                    <div style="font-size: 14px; opacity: 0.8; margin-top: 8px;">
                        ${fearGreedData.weekChange > 0 ? 'üìà' : 'üìâ'} ${fearGreedData.weekChange > 0 ? '+' : ''}${fearGreedData.weekChange} from last week
                    </div>
                ` : ''}
            </div>
            
            <!-- Risk Assessment -->
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Risk Level:</strong>
                        <span style="color: ${riskLevel.color}; font-weight: bold; margin-left: 8px;">
                            ${riskLevel.level}
                        </span>
                    </div>
                    <div style="background: ${riskLevel.color}; color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: bold;">
                        ${riskLevel.level.toUpperCase()}
                    </div>
                </div>
            </div>
            
            <!-- Recommendation -->
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="font-size: 14px; margin-bottom: 5px; opacity: 0.8;"><strong>üí° Trading Recommendation:</strong></div>
                <div style="font-size: 16px; line-height: 1.4;">
                    ${recommendation}
                </div>
            </div>
            
            <!-- Component Breakdown -->
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 15px;">üìà Market Factors Analysis</div>
                
                <div style="display: grid; gap: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Market Cap Change (24h)</span>
                        <span style="color: ${components.marketCap.value >= 0 ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">
                            ${components.marketCap.value >= 0 ? '+' : ''}${components.marketCap.value.toFixed(2)}%
                        </span>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Volume Change (24h)</span>
                        <span style="color: ${components.volume.value >= 0 ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">
                            ${components.volume.value >= 0 ? '+' : ''}${components.volume.value.toFixed(2)}%
                        </span>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Bitcoin Dominance</span>
                        <span style="font-weight: bold;">
                            ${components.dominance.value.toFixed(1)}%
                        </span>
                    </div>
                    
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Market Volatility</span>
                        <span style="color: ${components.volatility.value > 10 ? '#e74c3c' : components.volatility.value > 5 ? '#f39c12' : '#2ecc71'}; font-weight: bold;">
                            ${components.volatility.value.toFixed(2)}%
                        </span>
                    </div>
                </div>
            </div>
            
            <!-- Market Overview -->
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 16px; font-weight: bold; margin-bottom: 12px;">üåç Current Market Overview</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                    <div>
                        <div style="opacity: 0.8;">Total Market Cap</div>
                        <div style="font-weight: bold;">$${(marketData.marketCap / 1e12).toFixed(2)}T</div>
                    </div>
                    <div>
                        <div style="opacity: 0.8;">24h Volume</div>
                        <div style="font-weight: bold;">$${(marketData.volume / 1e9).toFixed(2)}B</div>
                    </div>
                    <div>
                        <div style="opacity: 0.8;">Bitcoin Price</div>
                        <div style="font-weight: bold;">$${marketData.btcPrice.toLocaleString()}</div>
                    </div>
                    <div>
                        <div style="opacity: 0.8;">BTC Dominance</div>
                        <div style="font-weight: bold;">${marketData.btcDominance.toFixed(1)}%</div>
                    </div>
                </div>
            </div>
            
            <div style="font-size: 12px; text-align: center; opacity: 0.7; margin-top: 15px;">
                ${fearGreedData.fallback ? '‚ö†Ô∏è Using calculated index (Official API unavailable)' : 'üìä Data from Alternative.me Fear & Greed Index'} ‚Ä¢ Updated: ${new Date().toLocaleTimeString()}
            </div>
        </div>
    `;
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    // Auto-calculate on page load to show current market sentiment
    setTimeout(() => {
        calculateFearGreed();
    }, 1000);
});

// Professional Crypto Tax Calculator with Real Tax Rates and Advanced Features
async function calculateTax() {
    const purchasePrice = parseFloat(document.getElementById('taxPurchasePrice').value);
    const salePrice = parseFloat(document.getElementById('taxSalePrice').value);
    const amount = parseFloat(document.getElementById('taxAmount').value);
    const manualTaxRate = parseFloat(document.getElementById('taxRate').value);
    
    if (!purchasePrice || !salePrice || !amount || 
        purchasePrice <= 0 || salePrice <= 0 || amount <= 0) {
        showResult('taxResult', 'Please enter valid purchase price, sale price, and amount', 'error');
        return;
    }

    showResult('taxResult', 'Calculating comprehensive tax analysis...', 'loading');

    try {
        // Get current crypto prices for additional context
        const currentData = await fetchCurrentCryptoData();
        
        // Get user's country/jurisdiction (can be enhanced with IP geolocation)
        const jurisdiction = await detectUserJurisdiction();
        
        // Perform comprehensive tax calculation
        const taxAnalysis = calculateComprehensiveTax({
            purchasePrice,
            salePrice,
            amount,
            manualTaxRate,
            jurisdiction,
            currentMarketData: currentData
        });

        // Generate professional tax report
        const result = generateTaxReport(taxAnalysis);
        showResult('taxResult', result);

    } catch (error) {
        console.error('Tax Calculator Error:', error);
        showResult('taxResult', 'Error performing tax calculation. Please try again.', 'error');
    }
}

// Fetch current crypto market data for context
async function fetchCurrentCryptoData() {
    try {
        const response = await fetch('https://api.coingecko.com/api/v3/global');
        const globalData = await response.json();
        
        const btcResponse = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true');
        const btcData = await btcResponse.json();
        
        return {
            totalMarketCap: globalData.data.total_market_cap.usd,
            btcPrice: btcData.bitcoin.usd,
            btcChange24h: btcData.bitcoin.usd_24h_change,
            activeCoins: globalData.data.active_cryptocurrencies,
            marketCapChange: globalData.data.market_cap_change_percentage_24h_usd
        };
    } catch (error) {
        return {
            totalMarketCap: 2000000000000, // Fallback values
            btcPrice: 120000,
            btcChange24h: 0,
            activeCoins: 10000,
            marketCapChange: 0
        };
    }
}

// Detect user jurisdiction (enhanced version would use IP geolocation)
async function detectUserJurisdiction() {
    // This could be enhanced with real IP geolocation service
    // For now, return default US jurisdiction
    return {
        country: 'US',
        shortTerm: 37, // Current max federal rate for short-term gains
        longTerm: 20,  // Current max federal rate for long-term gains
        stateTax: 0,   // Would vary by state
        holdingPeriodForLongTerm: 365, // days
        jurisdiction: 'United States'
    };
}

// Comprehensive tax calculation with real-world rules
function calculateComprehensiveTax(data) {
    const { purchasePrice, salePrice, amount, manualTaxRate, jurisdiction, currentMarketData } = data;
    
    // Basic calculations
    const totalPurchaseValue = purchasePrice * amount;
    const totalSaleValue = salePrice * amount;
    const capitalGainLoss = totalSaleValue - totalPurchaseValue;
    const gainLossPercentage = (capitalGainLoss / totalPurchaseValue) * 100;
    
    // Determine if it's a gain or loss
    const isGain = capitalGainLoss > 0;
    const isLoss = capitalGainLoss < 0;
    
    // Tax calculations based on jurisdiction
    let effectiveTaxRate = manualTaxRate || (isGain ? jurisdiction.shortTerm : 0);
    let taxOwed = 0;
    let netProceedsAfterTax = totalSaleValue;
    
    if (isGain && effectiveTaxRate > 0) {
        taxOwed = (capitalGainLoss * effectiveTaxRate) / 100;
        netProceedsAfterTax = totalSaleValue - taxOwed;
    }
    
    // Advanced calculations
    const breakEvenPrice = purchasePrice * (1 + (effectiveTaxRate / 100));
    const currentValue = amount * (currentMarketData.btcPrice || salePrice);
    const unrealizedGainLoss = currentValue - totalPurchaseValue;
    
    // Tax optimization suggestions
    const taxOptimization = calculateTaxOptimization({
        capitalGainLoss,
        taxRate: effectiveTaxRate,
        jurisdiction
    });
    
    // Risk assessment
    const riskAssessment = assessTaxRisk({
        gainLossPercentage,
        transactionSize: totalSaleValue,
        jurisdiction
    });

    return {
        // Basic Data
        purchasePrice,
        salePrice,
        amount,
        totalPurchaseValue,
        totalSaleValue,
        
        // Gain/Loss Analysis
        capitalGainLoss,
        gainLossPercentage,
        isGain,
        isLoss,
        
        // Tax Calculations
        effectiveTaxRate,
        taxOwed,
        netProceedsAfterTax,
        netProfit: netProceedsAfterTax - totalPurchaseValue,
        
        // Advanced Metrics
        breakEvenPrice,
        currentValue,
        unrealizedGainLoss,
        
        // Jurisdiction Info
        jurisdiction,
        
        // Analysis
        taxOptimization,
        riskAssessment,
        
        // Market Context
        currentMarketData
    };
}

// Calculate tax optimization strategies
function calculateTaxOptimization(data) {
    const { capitalGainLoss, taxRate, jurisdiction } = data;
    
    const strategies = [];
    
    if (capitalGainLoss > 0) {
        // Profitable trade strategies
        strategies.push({
            strategy: 'Tax Loss Harvesting',
            description: 'Consider realizing losses in other positions to offset gains',
            potentialSavings: `Up to $${(capitalGainLoss * taxRate / 100 * 0.5).toFixed(2)}`
        });
        
        strategies.push({
            strategy: 'HODL Strategy',
            description: 'Hold for >1 year to qualify for long-term capital gains',
            potentialSavings: `${jurisdiction.shortTerm - jurisdiction.longTerm}% tax reduction`
        });
    } else {
        // Loss strategies
        strategies.push({
            strategy: 'Tax Loss Deduction',
            description: 'Use losses to offset other capital gains or income',
            benefit: `Up to $${Math.min(Math.abs(capitalGainLoss), 3000)} annual deduction`
        });
    }
    
    strategies.push({
        strategy: 'DCA Out Strategy',
        description: 'Spread sales across multiple tax years to manage tax brackets',
        benefit: 'Potentially lower effective tax rate'
    });

    return strategies;
}

// Assess tax compliance risk
function assessTaxRisk(data) {
    const { gainLossPercentage, transactionSize, jurisdiction } = data;
    
    let riskLevel = 'Low';
    let riskColor = '#27ae60';
    const riskFactors = [];
    
    // Large transaction risk
    if (transactionSize > 100000) {
        riskFactors.push('Large transaction amount may trigger additional scrutiny');
        riskLevel = 'Medium';
        riskColor = '#f39c12';
    }
    
    // High gain risk
    if (Math.abs(gainLossPercentage) > 1000) {
        riskFactors.push('Extraordinary gains/losses may require additional documentation');
        riskLevel = 'Medium-High';
        riskColor = '#e67e22';
    }
    
    // Record keeping reminder
    riskFactors.push('Maintain detailed records of all transactions');
    riskFactors.push('Consider consulting a crypto tax professional for complex situations');

    return {
        level: riskLevel,
        color: riskColor,
        factors: riskFactors
    };
}

// Generate comprehensive tax report
function generateTaxReport(analysis) {
    const {
        purchasePrice, salePrice, amount, totalPurchaseValue, totalSaleValue,
        capitalGainLoss, gainLossPercentage, isGain, isLoss,
        effectiveTaxRate, taxOwed, netProceedsAfterTax, netProfit,
        breakEvenPrice, currentValue, unrealizedGainLoss,
        jurisdiction, taxOptimization, riskAssessment, currentMarketData
    } = analysis;

    return `
        <div style="background: linear-gradient(135deg, #2c3e50, #34495e); color: white; padding: 25px; border-radius: 15px; margin-top: 10px;">
            <div style="text-align: center; margin-bottom: 20px;">
                <h2 style="margin: 0; font-size: 24px;">üßæ Comprehensive Crypto Tax Analysis</h2>
                <div style="font-size: 14px; opacity: 0.8; margin-top: 5px;">
                    Jurisdiction: ${jurisdiction.jurisdiction} ‚Ä¢ ${new Date().toLocaleDateString()}
                </div>
            </div>

            <!-- Transaction Overview -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: #3498db;">üìä Transaction Summary</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 14px; opacity: 0.8;">Purchase Details</div>
                        <div style="font-size: 18px; font-weight: bold; margin: 5px 0;">
                            ${amount} units @ $${purchasePrice.toFixed(2)}
                        </div>
                        <div style="color: #95a5a6;">
                            Total: $${totalPurchaseValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 14px; opacity: 0.8;">Sale Details</div>
                        <div style="font-size: 18px; font-weight: bold; margin: 5px 0;">
                            ${amount} units @ $${salePrice.toFixed(2)}
                        </div>
                        <div style="color: #95a5a6;">
                            Total: $${totalSaleValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Gain/Loss Analysis -->
            <div style="background: ${isGain ? 'linear-gradient(135deg, #27ae60, #2ecc71)' : 'linear-gradient(135deg, #e74c3c, #c0392b)'}; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0;">üí∞ Capital ${isGain ? 'Gain' : 'Loss'} Analysis</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">
                    <div>
                        <div style="font-size: 14px; opacity: 0.9;">Total ${isGain ? 'Gain' : 'Loss'}</div>
                        <div style="font-size: 24px; font-weight: bold;">
                            ${isGain ? '+' : ''}$${capitalGainLoss.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 14px; opacity: 0.9;">Percentage ${isGain ? 'Gain' : 'Loss'}</div>
                        <div style="font-size: 24px; font-weight: bold;">
                            ${gainLossPercentage >= 0 ? '+' : ''}${gainLossPercentage.toFixed(2)}%
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 14px; opacity: 0.9;">Tax Owed</div>
                        <div style="font-size: 24px; font-weight: bold;">
                            $${taxOwed.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tax Calculation Details -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: #e67e22;">üî¢ Tax Calculation Breakdown</h3>
                <div style="display: grid; gap: 12px;">
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Effective Tax Rate</span>
                        <span style="font-weight: bold;">${effectiveTaxRate.toFixed(1)}%</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Gross Proceeds</span>
                        <span style="font-weight: bold;">$${totalSaleValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Cost Basis</span>
                        <span style="font-weight: bold;">$${totalPurchaseValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>Tax Liability</span>
                        <span style="font-weight: bold; color: ${taxOwed > 0 ? '#e74c3c' : '#2ecc71'};">$${taxOwed.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; padding: 12px 0; font-size: 18px; font-weight: bold; border-top: 2px solid rgba(255,255,255,0.3);">
                        <span>Net Profit After Tax</span>
                        <span style="color: ${netProfit > 0 ? '#2ecc71' : '#e74c3c'};">
                            $${netProfit.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </span>
                    </div>
                </div>
            </div>

            <!-- Advanced Analytics -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: #9b59b6;">üìà Advanced Tax Analytics</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 14px; opacity: 0.8;">Break-Even Price (After Tax)</div>
                        <div style="font-size: 16px; font-weight: bold; color: #f39c12;">
                            $${breakEvenPrice.toFixed(2)}
                        </div>
                        <div style="font-size: 12px; opacity: 0.7;">
                            Price needed to break even after taxes
                        </div>
                    </div>
                    <div>
                        <div style="font-size: 14px; opacity: 0.8;">Current Market Value</div>
                        <div style="font-size: 16px; font-weight: bold;">
                            $${currentValue.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        </div>
                        <div style="font-size: 12px; opacity: 0.7;">
                            Based on current BTC price: $${currentMarketData.btcPrice.toLocaleString()}
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                    <div style="font-size: 14px; margin-bottom: 5px;"><strong>Unrealized P&L:</strong></div>
                    <div style="color: ${unrealizedGainLoss > 0 ? '#2ecc71' : '#e74c3c'}; font-weight: bold;">
                        ${unrealizedGainLoss > 0 ? '+' : ''}$${unrealizedGainLoss.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}
                        (${((unrealizedGainLoss / totalPurchaseValue) * 100).toFixed(2)}%)
                    </div>
                </div>
            </div>

            <!-- Tax Optimization Strategies -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="margin: 0 0 15px 0; color: #1abc9c;">üí° Tax Optimization Strategies</h3>
                ${taxOptimization.map((strategy, index) => `
                    <div style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <div style="font-weight: bold; margin-bottom: 5px;">${index + 1}. ${strategy.strategy}</div>
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">${strategy.description}</div>
                        <div style="font-size: 13px; color: #2ecc71; font-weight: bold;">
                            ${strategy.potentialSavings || strategy.benefit}
                        </div>
                    </div>
                `).join('')}
            </div>

            <!-- Risk Assessment -->
            <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                <h3 style="margin: 0 0 15px 0; color: ${riskAssessment.color};">‚öñÔ∏è Tax Compliance Risk Assessment</h3>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <span><strong>Risk Level:</strong></span>
                    <span style="background: ${riskAssessment.color}; padding: 6px 15px; border-radius: 20px; font-weight: bold; font-size: 14px;">
                        ${riskAssessment.level.toUpperCase()}
                    </span>
                </div>
                ${riskAssessment.factors.map(factor => `
                    <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; margin-bottom: 8px; font-size: 14px;">
                        ‚Ä¢ ${factor}
                    </div>
                `).join('')}
            </div>

            <!-- Disclaimer -->
            <div style="background: rgba(231, 76, 60, 0.1); border: 1px solid rgba(231, 76, 60, 0.3); padding: 15px; border-radius: 8px; font-size: 13px;">
                <strong>‚ö†Ô∏è Important Disclaimer:</strong> This calculator provides estimates based on general tax principles. 
                Tax laws vary by jurisdiction and individual circumstances. Always consult with a qualified tax professional 
                for advice specific to your situation. This tool is for educational purposes only.
            </div>
        </div>
    `;
}

// Configuration
const COINGECKO_BASE_URL = 'https://api.coingecko.com/api/v3';
const CACHE_DURATION = 60000; // 1 minute cache
const cache = new Map();

// Rate limiting
let lastRequestTime = 0;
const REQUEST_DELAY = 1000; // 1 second between requests

// Utility function to delay requests
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Enhanced cache system
function getCacheKey(endpoint, params) {
    return `${endpoint}_${JSON.stringify(params)}`;
}

function isCacheValid(timestamp) {
    return Date.now() - timestamp < CACHE_DURATION;
}

// Robust API caller with retry logic
async function makeAPIRequest(url, retries = 3) {
    const now = Date.now();
    const timeSinceLastRequest = now - lastRequestTime;
    
    if (timeSinceLastRequest < REQUEST_DELAY) {
        await delay(REQUEST_DELAY - timeSinceLastRequest);
    }
    
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            lastRequestTime = Date.now();
            const response = await fetch(url, {
                headers: {
                    'Accept': 'application/json',
                }
            });
            
            if (!response.ok) {
                if (response.status === 429) {
                    // Rate limited, wait longer
                    const waitTime = Math.pow(2, attempt) * 1000;
                    console.warn(`Rate limited. Waiting ${waitTime}ms before retry ${attempt}`);
                    await delay(waitTime);
                    continue;
                }
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            return data;
            
        } catch (error) {
            console.error(`API request attempt ${attempt} failed:`, error.message);
            
            if (attempt === retries) {
                throw new Error(`API request failed after ${retries} attempts: ${error.message}`);
            }
            
            // Exponential backoff
            const waitTime = Math.pow(2, attempt) * 1000;
            await delay(waitTime);
        }
    }
}

// Get historical price data for technical analysis
async function getHistoricalData(coinId, days = 30) {
    const cacheKey = getCacheKey('historical', { coinId, days });
    const cachedData = cache.get(cacheKey);
    
    if (cachedData && isCacheValid(cachedData.timestamp)) {
        return cachedData.data;
    }
    
    const url = `${COINGECKO_BASE_URL}/coins/${coinId}/market_chart?vs_currency=usd&days=${days}&interval=daily`;
    const data = await makeAPIRequest(url);
    
    cache.set(cacheKey, {
        data: data,
        timestamp: Date.now()
    });
    
    return data;
}

// Get current market data
async function getCurrentMarketData(coinId) {
    const cacheKey = getCacheKey('current', { coinId });
    const cachedData = cache.get(cacheKey);
    
    if (cachedData && isCacheValid(cachedData.timestamp)) {
        return cachedData.data;
    }
    
    const url = `${COINGECKO_BASE_URL}/coins/${coinId}?localization=false&tickers=false&community_data=false&developer_data=false&sparkline=true`;
    const data = await makeAPIRequest(url);
    
    cache.set(cacheKey, {
        data: data,
        timestamp: Date.now()
    });
    
    return data;
}

// Technical Indicator Calculations

// RSI Calculation
function calculateRSI(prices, period = 14) {
    if (prices.length < period + 1) return null;
    
    const changes = [];
    for (let i = 1; i < prices.length; i++) {
        changes.push(prices[i] - prices[i - 1]);
    }
    
    let avgGain = 0;
    let avgLoss = 0;
    
    // Calculate initial averages
    for (let i = 0; i < period; i++) {
        if (changes[i] > 0) {
            avgGain += changes[i];
        } else {
            avgLoss += Math.abs(changes[i]);
        }
    }
    
    avgGain /= period;
    avgLoss /= period;
    
    // Calculate subsequent values using Wilder's smoothing
    for (let i = period; i < changes.length; i++) {
        const change = changes[i];
        if (change > 0) {
            avgGain = ((avgGain * (period - 1)) + change) / period;
            avgLoss = (avgLoss * (period - 1)) / period;
        } else {
            avgGain = (avgGain * (period - 1)) / period;
            avgLoss = ((avgLoss * (period - 1)) + Math.abs(change)) / period;
        }
    }
    
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

// Simple Moving Average
function calculateSMA(prices, period) {
    if (prices.length < period) return null;
    
    const sum = prices.slice(-period).reduce((acc, price) => acc + price, 0);
    return sum / period;
}

// Exponential Moving Average
function calculateEMA(prices, period) {
    if (prices.length < period) return null;
    
    const multiplier = 2 / (period + 1);
    let ema = calculateSMA(prices.slice(0, period), period);
    
    for (let i = period; i < prices.length; i++) {
        ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
    }
    
    return ema;
}

// MACD Calculation
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (prices.length < slowPeriod) return null;
    
    const fastEMA = calculateEMA(prices, fastPeriod);
    const slowEMA = calculateEMA(prices, slowPeriod);
    
    if (!fastEMA || !slowEMA) return null;
    
    const macdLine = fastEMA - slowEMA;
    
    // Calculate signal line (EMA of MACD line)
    const macdHistory = [];
    for (let i = slowPeriod - 1; i < prices.length; i++) {
        const slicePrices = prices.slice(0, i + 1);
        const fastEmaHist = calculateEMA(slicePrices, fastPeriod);
        const slowEmaHist = calculateEMA(slicePrices, slowPeriod);
        if (fastEmaHist && slowEmaHist) {
            macdHistory.push(fastEmaHist - slowEmaHist);
        }
    }
    
    const signalLine = calculateEMA(macdHistory, signalPeriod);
    const histogram = signalLine ? macdLine - signalLine : 0;
    
    return {
        macd: macdLine,
        signal: signalLine,
        histogram: histogram
    };
}

// Bollinger Bands
function calculateBollingerBands(prices, period = 20, stdDev = 2) {
    if (prices.length < period) return null;
    
    const sma = calculateSMA(prices, period);
    if (!sma) return null;
    
    const recentPrices = prices.slice(-period);
    const variance = recentPrices.reduce((acc, price) => {
        return acc + Math.pow(price - sma, 2);
    }, 0) / period;
    
    const standardDeviation = Math.sqrt(variance);
    
    return {
        upper: sma + (standardDeviation * stdDev),
        middle: sma,
        lower: sma - (standardDeviation * stdDev)
    };
}

// Volume analysis
function analyzeVolume(volumes) {
    if (volumes.length < 7) return null;
    
    const recent7Days = volumes.slice(-7);
    const previous7Days = volumes.slice(-14, -7);
    
    const recentAvg = recent7Days.reduce((a, b) => a + b, 0) / 7;
    const previousAvg = previous7Days.reduce((a, b) => a + b, 0) / 7;
    
    const volumeChange = ((recentAvg - previousAvg) / previousAvg) * 100;
    
    return {
        current: volumes[volumes.length - 1],
        averageRecent: recentAvg,
        averagePrevious: previousAvg,
        changePercent: volumeChange
    };
}

// Generate trading signals
function generateSignals(indicators, currentPrice) {
    const signals = [];
    let overallScore = 0;
    
    // RSI Signals
    if (indicators.rsi) {
        if (indicators.rsi > 70) {
            signals.push({ type: 'SELL', strength: 'Strong', reason: 'RSI Overbought (>70)' });
            overallScore -= 2;
        } else if (indicators.rsi > 60) {
            signals.push({ type: 'SELL', strength: 'Moderate', reason: 'RSI High (>60)' });
            overallScore -= 1;
        } else if (indicators.rsi < 30) {
            signals.push({ type: 'BUY', strength: 'Strong', reason: 'RSI Oversold (<30)' });
            overallScore += 2;
        } else if (indicators.rsi < 40) {
            signals.push({ type: 'BUY', strength: 'Moderate', reason: 'RSI Low (<40)' });
            overallScore += 1;
        }
    }
    
    // MACD Signals
    if (indicators.macd) {
        if (indicators.macd.macd > indicators.macd.signal && indicators.macd.histogram > 0) {
            signals.push({ type: 'BUY', strength: 'Moderate', reason: 'MACD Bullish Crossover' });
            overallScore += 1;
        } else if (indicators.macd.macd < indicators.macd.signal && indicators.macd.histogram < 0) {
            signals.push({ type: 'SELL', strength: 'Moderate', reason: 'MACD Bearish Crossover' });
            overallScore -= 1;
        }
    }
    
    // Moving Average Signals
    if (indicators.sma20 && indicators.sma50) {
        if (currentPrice > indicators.sma20 && indicators.sma20 > indicators.sma50) {
            signals.push({ type: 'BUY', strength: 'Moderate', reason: 'Price Above MA20 & MA50' });
            overallScore += 1;
        } else if (currentPrice < indicators.sma20 && indicators.sma20 < indicators.sma50) {
            signals.push({ type: 'SELL', strength: 'Moderate', reason: 'Price Below MA20 & MA50' });
            overallScore -= 1;
        }
    }
    
    // Bollinger Bands Signals
    if (indicators.bollingerBands) {
        if (currentPrice > indicators.bollingerBands.upper) {
            signals.push({ type: 'SELL', strength: 'Moderate', reason: 'Price Above Upper Bollinger Band' });
            overallScore -= 1;
        } else if (currentPrice < indicators.bollingerBands.lower) {
            signals.push({ type: 'BUY', strength: 'Moderate', reason: 'Price Below Lower Bollinger Band' });
            overallScore += 1;
        }
    }
    
    // Determine overall signal
    let overallSignal = 'NEUTRAL';
    if (overallScore >= 2) overallSignal = 'STRONG BUY';
    else if (overallScore > 0) overallSignal = 'BUY';
    else if (overallScore <= -2) overallSignal = 'STRONG SELL';
    else if (overallScore < 0) overallSignal = 'SELL';
    
    return {
        individual: signals,
        overall: overallSignal,
        score: overallScore
    };
}

// Main analysis function
async function analyzeTechnical() {
    const coinInput = document.getElementById('technicalCoin');
    const timeframeSelect = document.getElementById('timeframe');
    const resultDiv = document.getElementById('technicalResult');
    
    if (!coinInput || !timeframeSelect || !resultDiv) {
        console.error('Required DOM elements not found');
        return;
    }
    
    const coin = coinInput.value.toLowerCase().trim();
    const timeframe = timeframeSelect.value;
    
    if (!coin) {
        showResult('technicalResult', 'Please enter a cryptocurrency symbol or name', 'error');
        return;
    }
    
    showResult('technicalResult', 'Loading real-time data and calculating technical indicators...', 'loading');
    
    try {
        // Get timeframe-specific days
        const daysMap = {
            '1h': 7,    // 7 days for hourly analysis
            '4h': 30,   // 30 days for 4-hour analysis
            '1d': 90,   // 90 days for daily analysis
            '1w': 365   // 1 year for weekly analysis
        };
        const days = daysMap[timeframe] || 30;
        
        // Fetch data concurrently
        const [currentData, historicalData] = await Promise.all([
            getCurrentMarketData(coin),
            getHistoricalData(coin, days)
        ]);
        
        const currentPrice = currentData.market_data.current_price.usd;
        const change24h = currentData.market_data.price_change_percentage_24h;
        const marketCap = currentData.market_data.market_cap.usd;
        const volume24h = currentData.market_data.total_volume.usd;
        
        // Extract price data
        const prices = historicalData.prices.map(p => p[1]);
        const volumes = historicalData.total_volumes.map(v => v[1]);
        
        // Calculate technical indicators
        const indicators = {
            rsi: calculateRSI(prices, 14),
            sma20: calculateSMA(prices, 20),
            sma50: calculateSMA(prices, 50),
            sma200: calculateSMA(prices, 200),
            ema12: calculateEMA(prices, 12),
            ema26: calculateEMA(prices, 26),
            macd: calculateMACD(prices),
            bollingerBands: calculateBollingerBands(prices),
        };
        
        // Volume analysis
        const volumeAnalysis = analyzeVolume(volumes);
        
        // Generate trading signals
        const signals = generateSignals(indicators, currentPrice);
        
        // Format results
        const formatNumber = (num, decimals = 2) => {
            if (num === null || num === undefined) return 'N/A';
            if (num > 1000000000) return (num / 1000000000).toFixed(1) + 'B';
            if (num > 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num > 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toFixed(decimals);
        };
        
        const formatPrice = (price) => {
            if (price === null || price === undefined) return 'N/A';
            if (price < 0.01) return price.toFixed(6);
            if (price < 1) return price.toFixed(4);
            return price.toFixed(2);
        };
        
        // Get signal color
        const getSignalColor = (signal) => {
            switch(signal) {
                case 'STRONG BUY': return '#00C851';
                case 'BUY': return '#2E7D32';
                case 'STRONG SELL': return '#FF3547';
                case 'SELL': return '#C62828';
                default: return '#FFA726';
            }
        };
        
        const result = `
            <div class="technical-analysis-result">
                <div class="header-section">
                    <h3>${currentData.name} (${currentData.symbol.toUpperCase()}) - Technical Analysis</h3>
                    <div class="timeframe-badge">Timeframe: ${timeframe}</div>
                </div>
                
                <div class="price-section">
                    <div class="current-price">$${formatPrice(currentPrice)}</div>
                    <div class="price-change ${change24h >= 0 ? 'positive' : 'negative'}">
                        ${change24h >= 0 ? '+' : ''}${change24h?.toFixed(2) || 'N/A'}% (24h)
                    </div>
                </div>
                
                <div class="market-info">
                    <div class="info-item">
                        <span class="label">Market Cap:</span>
                        <span class="value">$${formatNumber(marketCap)}</span>
                    </div>
                    <div class="info-item">
                        <span class="label">24h Volume:</span>
                        <span class="value">$${formatNumber(volume24h)}</span>
                    </div>
                </div>
                
                <div class="indicators-section">
                    <h4>Technical Indicators</h4>
                    <div class="indicators-grid">
                        <div class="indicator">
                            <span class="label">RSI (14):</span>
                            <span class="value">${indicators.rsi?.toFixed(1) || 'N/A'}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">SMA (20):</span>
                            <span class="value">$${formatPrice(indicators.sma20)}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">SMA (50):</span>
                            <span class="value">$${formatPrice(indicators.sma50)}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">SMA (200):</span>
                            <span class="value">$${formatPrice(indicators.sma200)}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">MACD:</span>
                            <span class="value">${indicators.macd ? indicators.macd.macd.toFixed(4) : 'N/A'}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">Signal Line:</span>
                            <span class="value">${indicators.macd?.signal ? indicators.macd.signal.toFixed(4) : 'N/A'}</span>
                        </div>
                        ${indicators.bollingerBands ? `
                        <div class="indicator">
                            <span class="label">BB Upper:</span>
                            <span class="value">$${formatPrice(indicators.bollingerBands.upper)}</span>
                        </div>
                        <div class="indicator">
                            <span class="label">BB Lower:</span>
                            <span class="value">$${formatPrice(indicators.bollingerBands.lower)}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                
                ${volumeAnalysis ? `
                <div class="volume-section">
                    <h4>Volume Analysis</h4>
                    <div class="volume-info">
                        <div class="volume-item">
                            <span class="label">Current Volume:</span>
                            <span class="value">$${formatNumber(volumeAnalysis.current)}</span>
                        </div>
                        <div class="volume-item">
                            <span class="label">7-Day Avg Change:</span>
                            <span class="value ${volumeAnalysis.changePercent >= 0 ? 'positive' : 'negative'}">
                                ${volumeAnalysis.changePercent >= 0 ? '+' : ''}${volumeAnalysis.changePercent.toFixed(1)}%
                            </span>
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <div class="signals-section">
                    <div class="overall-signal">
                        <span class="label">Overall Signal:</span>
                        <span class="signal-badge" style="background-color: ${getSignalColor(signals.overall)}; color: white; padding: 4px 8px; border-radius: 4px;">
                            ${signals.overall}
                        </span>
                        <span class="signal-score">(Score: ${signals.score})</span>
                    </div>
                    
                    ${signals.individual.length > 0 ? `
                    <div class="individual-signals">
                        <h4>Individual Signals</h4>
                        <div class="signals-list">
                            ${signals.individual.map(signal => `
                                <div class="signal-item">
                                    <span class="signal-type ${signal.type.toLowerCase()}">${signal.type}</span>
                                    <span class="signal-strength">${signal.strength}</span>
                                    <span class="signal-reason">${signal.reason}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                </div>
                
                <div class="disclaimer">
                    <small><strong>Disclaimer:</strong> This analysis is for informational purposes only and should not be considered as financial advice. Always conduct your own research and consider your risk tolerance before making investment decisions.</small>
                </div>
                
                <div class="data-source">
                    <small>Data provided by CoinGecko API ‚Ä¢ Last updated: ${new Date().toLocaleString()}</small>
                </div>
            </div>
        `;
        
        showResult('technicalResult', result);
        
    } catch (error) {
        console.error('Technical analysis error:', error);
        
        let errorMessage = 'Unable to perform technical analysis. ';
        
        if (error.message.includes('HTTP 404')) {
            errorMessage += 'Cryptocurrency not found. Please check the symbol/name.';
        } else if (error.message.includes('HTTP 429')) {
            errorMessage += 'Rate limit exceeded. Please try again in a moment.';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage += 'Network error. Please check your internet connection.';
        } else {
            errorMessage += 'Please try again later.';
        }
        
        showResult('technicalResult', errorMessage, 'error');
    }
}

// Helper function (assuming it exists in your codebase)
function showResult(elementId, content, type = 'success') {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    element.innerHTML = content;
    element.className = `result ${type}`;
}

// Initialize and export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { analyzeTechnical };
}

// Trading Simulator Configuration
const TRADING_CONFIG = {
    baseUrl: 'https://api.coingecko.com/api/v3',
    cacheDuration: 30000, // 30 seconds for trading data
    maxRetries: 3,
    requestDelay: 800, // Faster for trading
    defaultFees: {
        maker: 0.001,    // 0.1% maker fee
        taker: 0.0015,   // 0.15% taker fee
        withdrawal: 0.0005 // 0.05% withdrawal fee
    },
    slippageRange: {
        low: 0.0001,     // 0.01% for high liquidity
        medium: 0.002,   // 0.2% for medium liquidity  
        high: 0.005      // 0.5% for low liquidity
    }
};

// Trading Cache System
class TradingCache {
    constructor() {
        this.cache = new Map();
        this.requestTimes = new Map();
    }
    
    getKey(endpoint, params) {
        return `${endpoint}_${JSON.stringify(params)}`;
    }
    
    isValid(key) {
        const data = this.cache.get(key);
        if (!data) return false;
        return Date.now() - data.timestamp < TRADING_CONFIG.cacheDuration;
    }
    
    set(key, data) {
        this.cache.set(key, {
            data: data,
            timestamp: Date.now()
        });
    }
    
    get(key) {
        const cached = this.cache.get(key);
        return cached ? cached.data : null;
    }
    
    async makeRequest(url, options = {}) {
        const now = Date.now();
        const lastRequest = this.requestTimes.get('last') || 0;
        
        // Rate limiting
        if (now - lastRequest < TRADING_CONFIG.requestDelay) {
            await new Promise(resolve => 
                setTimeout(resolve, TRADING_CONFIG.requestDelay - (now - lastRequest))
            );
        }
        
        for (let attempt = 1; attempt <= TRADING_CONFIG.maxRetries; attempt++) {
            try {
                this.requestTimes.set('last', Date.now());
                
                const response = await fetch(url, {
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    if (response.status === 429) {
                        const waitTime = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                return await response.json();
                
            } catch (error) {
                if (attempt === TRADING_CONFIG.maxRetries) {
                    throw new Error(`Request failed after ${TRADING_CONFIG.maxRetries} attempts: ${error.message}`);
                }
                
                const waitTime = Math.pow(2, attempt) * 500;
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
}

// Trading Portfolio Management
class TradingPortfolio {
    constructor(initialBalance = 10000) {
        this.balance = initialBalance;
        this.holdings = new Map();
        this.tradeHistory = [];
        this.totalDeposited = initialBalance;
        this.totalFees = 0;
        this.totalPnL = 0;
    }
    
    addHolding(symbol, amount, price) {
        const existing = this.holdings.get(symbol) || { amount: 0, avgPrice: 0, totalValue: 0 };
        const newTotalValue = existing.totalValue + (amount * price);
        const newTotalAmount = existing.amount + amount;
        const newAvgPrice = newTotalAmount > 0 ? newTotalValue / newTotalAmount : 0;
        
        this.holdings.set(symbol, {
            amount: newTotalAmount,
            avgPrice: newAvgPrice,
            totalValue: newTotalValue,
            lastPrice: price,
            lastUpdate: Date.now()
        });
    }
    
    removeHolding(symbol, amount) {
        const holding = this.holdings.get(symbol);
        if (!holding || holding.amount < amount) return false;
        
        const newAmount = holding.amount - amount;
        if (newAmount <= 0.00000001) { // Dust threshold
            this.holdings.delete(symbol);
        } else {
            this.holdings.set(symbol, {
                ...holding,
                amount: newAmount,
                totalValue: newAmount * holding.avgPrice
            });
        }
        return true;
    }
    
    getHolding(symbol) {
        return this.holdings.get(symbol) || null;
    }
    
    getTotalPortfolioValue(currentPrices) {
        let totalValue = this.balance;
        
        for (const [symbol, holding] of this.holdings) {
            const currentPrice = currentPrices[symbol] || holding.lastPrice;
            totalValue += holding.amount * currentPrice;
        }
        
        return totalValue;
    }
    
    addTrade(trade) {
        this.tradeHistory.push({
            ...trade,
            timestamp: Date.now(),
            id: this.generateTradeId()
        });
    }
    
    generateTradeId() {
        return 'TXN_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }
}

// Initialize systems
const tradingCache = new TradingCache();
const portfolio = new TradingPortfolio();

// Get real-time market data for trading
async function getMarketData(coinId) {
    const cacheKey = tradingCache.getKey('market', { coinId });
    
    if (tradingCache.isValid(cacheKey)) {
        return tradingCache.get(cacheKey);
    }
    
    const url = `${TRADING_CONFIG.baseUrl}/coins/${coinId}?localization=false&tickers=true&market_data=true&community_data=false&developer_data=false`;
    const data = await tradingCache.makeRequest(url);
    
    tradingCache.set(cacheKey, data);
    return data;
}

// Get orderbook simulation data
async function getOrderbookData(coinId) {
    const cacheKey = tradingCache.getKey('tickers', { coinId });
    
    if (tradingCache.isValid(cacheKey)) {
        return tradingCache.get(cacheKey);
    }
    
    const url = `${TRADING_CONFIG.baseUrl}/coins/${coinId}/tickers?include_exchange_logo=false&page=1&depth=true`;
    const data = await tradingCache.makeRequest(url);
    
    tradingCache.set(cacheKey, data);
    return data;
}

// Calculate realistic slippage based on market conditions
function calculateSlippage(volume24h, tradeAmount, currentPrice) {
    const tradeRatio = (tradeAmount / currentPrice) / volume24h;
    
    let slippage;
    if (tradeRatio < 0.00001) {        // < 0.001% of daily volume
        slippage = TRADING_CONFIG.slippageRange.low;
    } else if (tradeRatio < 0.0001) {   // < 0.01% of daily volume
        slippage = TRADING_CONFIG.slippageRange.medium;
    } else {                            // > 0.01% of daily volume
        slippage = TRADING_CONFIG.slippageRange.high;
    }
    
    // Add some randomness
    const randomFactor = (Math.random() - 0.5) * 0.5; // ¬±25% variation
    return slippage * (1 + randomFactor);
}

// Calculate trading fees
function calculateFees(tradeAmount, orderType = 'market') {
    const feeRate = orderType === 'market' ? 
        TRADING_CONFIG.defaultFees.taker : 
        TRADING_CONFIG.defaultFees.maker;
    
    return tradeAmount * feeRate;
}

// Simulate order execution
function simulateOrderExecution(orderType, tradeAmount, currentPrice, marketData) {
    const volume24h = marketData.market_data.total_volume.usd;
    const slippage = calculateSlippage(volume24h, tradeAmount, currentPrice);
    
    let executionPrice;
    if (orderType === 'buy') {
        // Buy orders typically execute at higher prices due to slippage
        executionPrice = currentPrice * (1 + slippage);
    } else {
        // Sell orders typically execute at lower prices due to slippage
        executionPrice = currentPrice * (1 - slippage);
    }
    
    // Simulate partial fills for large orders
    const maxSingleFill = volume24h * 0.001; // Max 0.1% of daily volume in single order
    const orderValue = tradeAmount;
    
    let fills = [];
    let remainingAmount = tradeAmount;
    let avgExecutionPrice = 0;
    let totalExecuted = 0;
    
    while (remainingAmount > 0 && fills.length < 10) { // Max 10 fills
        const fillAmount = Math.min(remainingAmount, maxSingleFill / currentPrice);
        const fillSlippage = slippage * (fills.length * 0.1); // Increasing slippage
        
        const fillPrice = orderType === 'buy' ? 
            currentPrice * (1 + fillSlippage) : 
            currentPrice * (1 - fillSlippage);
        
        fills.push({
            amount: fillAmount,
            price: fillPrice,
            timestamp: Date.now() + (fills.length * 100) // Stagger fills
        });
        
        totalExecuted += fillAmount * fillPrice;
        remainingAmount -= fillAmount;
        
        if (fillAmount * fillPrice < 10) break; // Min fill size $10
    }
    
    avgExecutionPrice = totalExecuted / (tradeAmount - remainingAmount);
    
    return {
        fills: fills,
        avgExecutionPrice: avgExecutionPrice,
        totalSlippage: Math.abs(avgExecutionPrice - currentPrice) / currentPrice,
        executedAmount: tradeAmount - remainingAmount,
        partialFill: remainingAmount > 0
    };
}

// Main trading simulation function
async function simulateTrade() {
    const balanceInput = document.getElementById('virtualBalance');
    const coinInput = document.getElementById('tradingCoin');
    const tradeTypeSelect = document.getElementById('tradeType');
    const tradeAmountInput = document.getElementById('tradeAmount');
    const resultDiv = document.getElementById('tradingResult');
    
    if (!balanceInput || !coinInput || !tradeTypeSelect || !tradeAmountInput || !resultDiv) {
        console.error('Required trading form elements not found');
        return;
    }
    
    const balance = parseFloat(balanceInput.value);
    const coin = coinInput.value.toLowerCase().trim();
    const tradeType = tradeTypeSelect.value;
    const tradeAmount = parseFloat(tradeAmountInput.value);
    
    // Input validation
    if (!coin) {
        showResult('tradingResult', 'Please enter a cryptocurrency symbol or name', 'error');
        return;
    }
    
    if (!balance || !tradeAmount || balance <= 0 || tradeAmount <= 0) {
        showResult('tradingResult', 'Please enter valid positive values for balance and trade amount', 'error');
        return;
    }
    
    if (tradeAmount > balance) {
        showResult('tradingResult', 'Insufficient balance for this trade', 'error');
        return;
    }
    
    if (tradeAmount < 10) {
        showResult('tradingResult', 'Minimum trade amount is $10', 'error');
        return;
    }
    
    showResult('tradingResult', 'Executing trade with real market data...', 'loading');
    
    try {
        // Get real market data
        const marketData = await getMarketData(coin);
        const currentPrice = marketData.market_data.current_price.usd;
        const volume24h = marketData.market_data.total_volume.usd;
        const marketCap = marketData.market_data.market_cap.usd;
        const priceChange24h = marketData.market_data.price_change_percentage_24h;
        
        // Calculate trade details
        const cryptoAmount = tradeAmount / currentPrice;
        const tradingFee = calculateFees(tradeAmount, 'market');
        const netTradeAmount = tradeAmount - tradingFee;
        
        // Simulate order execution
        const execution = simulateOrderExecution(tradeType, tradeAmount, currentPrice, marketData);
        
        // Update portfolio
        const newBalance = balance - tradeAmount;
        portfolio.balance = newBalance;
        portfolio.totalFees += tradingFee;
        
        if (tradeType === 'buy') {
            portfolio.addHolding(marketData.symbol.toUpperCase(), cryptoAmount, execution.avgExecutionPrice);
        } else {
            // For sell simulation, assume we had the holding
            portfolio.removeHolding(marketData.symbol.toUpperCase(), cryptoAmount);
        }
        
        // Record trade
        const trade = {
            type: tradeType,
            symbol: marketData.symbol.toUpperCase(),
            amount: cryptoAmount,
            usdAmount: tradeAmount,
            executionPrice: execution.avgExecutionPrice,
            marketPrice: currentPrice,
            slippage: execution.totalSlippage,
            fee: tradingFee,
            fills: execution.fills.length,
            partialFill: execution.partialFill
        };
        
        portfolio.addTrade(trade);
        
        // Calculate PnL if selling
        let pnlInfo = '';
        if (tradeType === 'sell') {
            const holding = portfolio.getHolding(marketData.symbol.toUpperCase());
            if (holding) {
                const pnl = (execution.avgExecutionPrice - holding.avgPrice) * cryptoAmount;
                const pnlPercent = ((execution.avgExecutionPrice - holding.avgPrice) / holding.avgPrice) * 100;
                portfolio.totalPnL += pnl;
                
                pnlInfo = `
                    <div class="pnl-section">
                        <h4>Profit/Loss Analysis</h4>
                        <div class="pnl-info">
                            <div class="pnl-item">
                                <span class="label">Avg Buy Price:</span>
                                <span class="value">$${holding.avgPrice.toFixed(6)}</span>
                            </div>
                            <div class="pnl-item">
                                <span class="label">Sell Price:</span>
                                <span class="value">$${execution.avgExecutionPrice.toFixed(6)}</span>
                            </div>
                            <div class="pnl-item">
                                <span class="label">P&L:</span>
                                <span class="value ${pnl >= 0 ? 'positive' : 'negative'}">
                                    ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)} (${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%)
                                </span>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Format results
        const formatNumber = (num, decimals = 2) => {
            if (num > 1000000000) return (num / 1000000000).toFixed(1) + 'B';
            if (num > 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num > 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toFixed(decimals);
        };
        
        const formatPrice = (price) => {
            if (price < 0.01) return price.toFixed(6);
            if (price < 1) return price.toFixed(4);
            return price.toFixed(2);
        };
        
        // Get market condition indicator
        const getMarketCondition = (volume24h, marketCap) => {
            const volumeRatio = volume24h / marketCap;
            if (volumeRatio > 0.1) return { condition: 'High Liquidity', color: '#00C851' };
            if (volumeRatio > 0.05) return { condition: 'Medium Liquidity', color: '#FFA726' };
            return { condition: 'Low Liquidity', color: '#FF3547' };
        };
        
        const marketCondition = getMarketCondition(volume24h, marketCap);
        
        const result = `
            <div class="trading-result">
                <div class="trade-header">
                    <h3>‚úÖ Trade Executed Successfully</h3>
                    <div class="trade-id">Trade ID: ${trade.id || portfolio.generateTradeId()}</div>
                </div>
                
                <div class="market-info-section">
                    <h4>${marketData.name} (${marketData.symbol.toUpperCase()}) Market Info</h4>
                    <div class="market-grid">
                        <div class="market-item">
                            <span class="label">Current Price:</span>
                            <span class="value">$${formatPrice(currentPrice)}</span>
                        </div>
                        <div class="market-item">
                            <span class="label">24h Change:</span>
                            <span class="value ${priceChange24h >= 0 ? 'positive' : 'negative'}">
                                ${priceChange24h >= 0 ? '+' : ''}${priceChange24h?.toFixed(2) || 'N/A'}%
                            </span>
                        </div>
                        <div class="market-item">
                            <span class="label">24h Volume:</span>
                            <span class="value">$${formatNumber(volume24h)}</span>
                        </div>
                        <div class="market-item">
                            <span class="label">Market Cap:</span>
                            <span class="value">$${formatNumber(marketCap)}</span>
                        </div>
                        <div class="market-item">
                            <span class="label">Liquidity:</span>
                            <span class="value" style="color: ${marketCondition.color}">
                                ${marketCondition.condition}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="execution-details">
                    <h4>Execution Details</h4>
                    <div class="execution-grid">
                        <div class="execution-item">
                            <span class="label">Trade Type:</span>
                            <span class="value trade-type ${tradeType}">${tradeType.toUpperCase()}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">USD Amount:</span>
                            <span class="value">$${tradeAmount.toFixed(2)}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Crypto Amount:</span>
                            <span class="value">${cryptoAmount.toFixed(8)} ${marketData.symbol.toUpperCase()}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Market Price:</span>
                            <span class="value">$${formatPrice(currentPrice)}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Avg Execution:</span>
                            <span class="value">$${formatPrice(execution.avgExecutionPrice)}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Slippage:</span>
                            <span class="value ${execution.totalSlippage > 0.01 ? 'warning' : 'success'}">
                                ${(execution.totalSlippage * 100).toFixed(3)}%
                            </span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Order Fills:</span>
                            <span class="value">${execution.fills.length} ${execution.partialFill ? '(Partial)' : '(Complete)'}</span>
                        </div>
                        <div class="execution-item">
                            <span class="label">Trading Fee:</span>
                            <span class="value">$${tradingFee.toFixed(4)}</span>
                        </div>
                    </div>
                </div>
                
                ${pnlInfo}
                
                <div class="balance-section">
                    <h4>Portfolio Update</h4>
                    <div class="balance-grid">
                        <div class="balance-item">
                            <span class="label">Previous Balance:</span>
                            <span class="value">$${balance.toFixed(2)}</span>
                        </div>
                        <div class="balance-item">
                            <span class="label">Current Balance:</span>
                            <span class="value">$${newBalance.toFixed(2)}</span>
                        </div>
                        <div class="balance-item">
                            <span class="label">Total Fees Paid:</span>
                            <span class="value">$${portfolio.totalFees.toFixed(4)}</span>
                        </div>
                        ${portfolio.totalPnL !== 0 ? `
                        <div class="balance-item">
                            <span class="label">Total P&L:</span>
                            <span class="value ${portfolio.totalPnL >= 0 ? 'positive' : 'negative'}">
                                ${portfolio.totalPnL >= 0 ? '+' : ''}$${portfolio.totalPnL.toFixed(2)}
                            </span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="holdings-section">
                    <h4>Current Holdings</h4>
                    ${portfolio.holdings.size > 0 ? `
                        <div class="holdings-list">
                            ${Array.from(portfolio.holdings.entries()).map(([symbol, holding]) => `
                                <div class="holding-item">
                                    <span class="holding-symbol">${symbol}</span>
                                    <span class="holding-amount">${holding.amount.toFixed(8)}</span>
                                    <span class="holding-value">~$${(holding.amount * holding.lastPrice).toFixed(2)}</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : '<div class="no-holdings">No crypto holdings</div>'}
                </div>
                
                <div class="trade-summary">
                    <div class="summary-status">
                        <span class="status-badge success">COMPLETED</span>
                        <span class="execution-time">${new Date().toLocaleTimeString()}</span>
                    </div>
                </div>
                
                <div class="disclaimer">
                    <small><strong>Simulation Notice:</strong> This is a simulated trade using real market data. Actual trading involves additional risks, costs, and market conditions not fully represented here.</small>
                </div>
                
                <div class="data-source">
                    <small>Market data by CoinGecko API ‚Ä¢ Executed at: ${new Date().toLocaleString()}</small>
                </div>
            </div>
        `;
        
        showResult('tradingResult', result);
        
        // Update balance input for next trade
        balanceInput.value = newBalance.toFixed(2);
        
    } catch (error) {
        console.error('Trading simulation error:', error);
        
        let errorMessage = 'Unable to execute trade. ';
        
        if (error.message.includes('HTTP 404')) {
            errorMessage += 'Cryptocurrency not found. Please check the symbol/name.';
        } else if (error.message.includes('HTTP 429')) {
            errorMessage += 'Rate limit exceeded. Please try again in a moment.';
        } else if (error.message.includes('Failed to fetch')) {
            errorMessage += 'Network error. Please check your internet connection.';
        } else {
            errorMessage += 'Please try again later.';
        }
        
        showResult('tradingResult', errorMessage, 'error');
    }
}

// Reset portfolio function
function resetPortfolio() {
    const balanceInput = document.getElementById('virtualBalance');
    if (balanceInput) {
        balanceInput.value = '10000.00';
    }
    
    portfolio.balance = 10000;
    portfolio.holdings.clear();
    portfolio.tradeHistory = [];
    portfolio.totalDeposited = 10000;
    portfolio.totalFees = 0;
    portfolio.totalPnL = 0;
    
    showResult('tradingResult', 'Portfolio has been reset to $10,000 USD', 'success');
}

// Portfolio analysis function
function analyzePortfolio() {
    if (portfolio.tradeHistory.length === 0) {
        showResult('tradingResult', 'No trades executed yet. Make some trades first!', 'error');
        return;
    }
    
    const totalTrades = portfolio.tradeHistory.length;
    const buyTrades = portfolio.tradeHistory.filter(t => t.type === 'buy').length;
    const sellTrades = portfolio.tradeHistory.filter(t => t.type === 'sell').length;
    const avgSlippage = portfolio.tradeHistory.reduce((sum, t) => sum + t.slippage, 0) / totalTrades;
    
    const analysis = `
        <div class="portfolio-analysis">
            <h3>Portfolio Analysis</h3>
            <div class="analysis-grid">
                <div class="analysis-item">
                    <span class="label">Total Trades:</span>
                    <span class="value">${totalTrades}</span>
                </div>
                <div class="analysis-item">
                    <span class="label">Buy Orders:</span>
                    <span class="value">${buyTrades}</span>
                </div>
                <div class="analysis-item">
                    <span class="label">Sell Orders:</span>
                    <span class="value">${sellTrades}</span>
                </div>
                <div class="analysis-item">
                    <span class="label">Total Fees:</span>
                    <span class="value">$${portfolio.totalFees.toFixed(4)}</span>
                </div>
                <div class="analysis-item">
                    <span class="label">Avg Slippage:</span>
                    <span class="value">${(avgSlippage * 100).toFixed(3)}%</span>
                </div>
                <div class="analysis-item">
                    <span class="label">Total P&L:</span>
                    <span class="value ${portfolio.totalPnL >= 0 ? 'positive' : 'negative'}">
                        ${portfolio.totalPnL >= 0 ? '+' : ''}$${portfolio.totalPnL.toFixed(2)}
                    </span>
                </div>
            </div>
        </div>
    `;
    
    showResult('tradingResult', analysis);
}

// Export functions for global access
if (typeof window !== 'undefined') {
    window.simulateTrade = simulateTrade;
    window.resetPortfolio = resetPortfolio;
    window.analyzePortfolio = analyzePortfolio;
}

// Helper function (assuming it exists)
function showResult(elementId, content, type = 'success') {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    element.innerHTML = content;
    element.className = `result ${type}`;
}

// Module export for Node.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { simulateTrade, resetPortfolio, analyzePortfolio, TradingPortfolio };
}

// Mining Calculator Configuration
const MINING_CONFIG = {
    coingeckoApi: 'https://api.coingecko.com/api/v3',
    poolApiEndpoints: {
        btc: 'https://blockchain.info/q/getdifficulty',
        eth: 'https://api.etherscan.io/api?module=stats&action=ethprice',
        etc: 'https://blockscout.com/etc/mainnet/api',
        ltc: 'https://chainz.cryptoid.info/ltc/api.dws?q=getdifficulty',
        bch: 'https://rest.bitcoin.com/v2/blockchain/getDifficulty',
        zec: 'https://zcashnetwork.info/api/info',
        xmr: 'https://moneroblocks.info/api/get_stats'
    },
    cacheDuration: 180000, // 3 minutes for mining data
    requestDelay: 1000,
    maxRetries: 3
};

// Comprehensive cryptocurrency mining data
const MINING_ALGORITHMS = {
    bitcoin: {
        symbol: 'BTC',
        algorithm: 'SHA-256',
        hashRateUnit: 'TH/s',
        blockTime: 600, // 10 minutes
        blockReward: 6.25,
        difficultyAdjustment: 2016, // blocks
        networkHashrateEndpoint: 'btc'
    },
    ethereum: {
        symbol: 'ETH',
        algorithm: 'Ethash',
        hashRateUnit: 'MH/s',
        blockTime: 13.3,
        blockReward: 2.0,
        difficultyAdjustment: 1, // dynamic
        networkHashrateEndpoint: 'eth',
        note: 'ETH moved to Proof of Stake - Historical data only'
    },
    'ethereum-classic': {
        symbol: 'ETC',
        algorithm: 'Ethash',
        hashRateUnit: 'MH/s',
        blockTime: 13.3,
        blockReward: 3.2,
        difficultyAdjustment: 1,
        networkHashrateEndpoint: 'etc'
    },
    litecoin: {
        symbol: 'LTC',
        algorithm: 'Scrypt',
        hashRateUnit: 'MH/s',
        blockTime: 150, // 2.5 minutes
        blockReward: 12.5,
        difficultyAdjustment: 2016,
        networkHashrateEndpoint: 'ltc'
    },
    'bitcoin-cash': {
        symbol: 'BCH',
        algorithm: 'SHA-256',
        hashRateUnit: 'TH/s',
        blockTime: 600,
        blockReward: 6.25,
        difficultyAdjustment: 144, // DAA
        networkHashrateEndpoint: 'bch'
    },
    zcash: {
        symbol: 'ZEC',
        algorithm: 'Equihash',
        hashRateUnit: 'Sol/s',
        blockTime: 75,
        blockReward: 3.125,
        difficultyAdjustment: 1,
        networkHashrateEndpoint: 'zec'
    },
    monero: {
        symbol: 'XMR',
        algorithm: 'RandomX',
        hashRateUnit: 'H/s',
        blockTime: 120,
        blockReward: 0, // Dynamic based on emission
        difficultyAdjustment: 1,
        networkHashrateEndpoint: 'xmr'
    },
    dogecoin: {
        symbol: 'DOGE',
        algorithm: 'Scrypt',
        hashRateUnit: 'MH/s',
        blockTime: 60,
        blockReward: 10000,
        difficultyAdjustment: 1,
        networkHashrateEndpoint: 'ltc' // Uses same algo as LTC
    },
    dash: {
        symbol: 'DASH',
        algorithm: 'X11',
        hashRateUnit: 'GH/s',
        blockTime: 150,
        blockReward: 2.88,
        difficultyAdjustment: 24,
        networkHashrateEndpoint: null
    }
};

// Mining hardware database
const MINING_HARDWARE = {
    'SHA-256': [
        { name: 'Antminer S19 XP', hashrate: 140, power: 3010, efficiency: 21.5 },
        { name: 'Antminer S19j Pro', hashrate: 104, power: 3068, efficiency: 29.5 },
        { name: 'Antminer S19 Pro', hashrate: 110, power: 3250, efficiency: 29.5 },
        { name: 'Antminer S17+', hashrate: 73, power: 2920, efficiency: 40 },
        { name: 'WhatsMiner M30S++', hashrate: 112, power: 3472, efficiency: 31 },
        { name: 'WhatsMiner M21S', hashrate: 56, power: 3360, efficiency: 60 }
    ],
    'Ethash': [
        { name: 'RTX 4090', hashrate: 130, power: 450, efficiency: 3.46 },
        { name: 'RTX 3090', hashrate: 120, power: 350, efficiency: 2.92 },
        { name: 'RTX 3080', hashrate: 100, power: 320, efficiency: 3.13 },
        { name: 'RTX 3070', hashrate: 62, power: 220, efficiency: 2.82 },
        { name: 'RX 6800 XT', hashrate: 65, power: 300, efficiency: 4.62 },
        { name: 'RX 5700 XT', hashrate: 55, power: 225, efficiency: 4.09 }
    ],
    'Scrypt': [
        { name: 'Antminer L7', hashrate: 9500, power: 3425, efficiency: 0.36 },
        { name: 'Antminer L3++', hashrate: 596, power: 1050, efficiency: 1.76 },
        { name: 'Innosilicon A6+', hashrate: 2200, power: 2100, efficiency: 0.95 }
    ],
    'RandomX': [
        { name: 'AMD Ryzen 9 5950X', hashrate: 15000, power: 280, efficiency: 53.6 },
        { name: 'AMD Ryzen 7 5800X', hashrate: 11000, power: 200, efficiency: 55 },
        { name: 'Intel i9-12900K', hashrate: 8500, power: 250, efficiency: 34 }
    ]
};

// Mining Cache System
class MiningCache {
    constructor() {
        this.cache = new Map();
        this.networkData = new Map();
    }
    
    getKey(endpoint, params = {}) {
        return `${endpoint}_${JSON.stringify(params)}`;
    }
    
    isValid(key) {
        const data = this.cache.get(key);
        if (!data) return false;
        return Date.now() - data.timestamp < MINING_CONFIG.cacheDuration;
    }
    
    set(key, data) {
        this.cache.set(key, {
            data: data,
            timestamp: Date.now()
        });
    }
    
    get(key) {
        const cached = this.cache.get(key);
        return cached ? cached.data : null;
    }
    
    async makeRequest(url, options = {}) {
        for (let attempt = 1; attempt <= MINING_CONFIG.maxRetries; attempt++) {
            try {
                await new Promise(resolve => setTimeout(resolve, MINING_CONFIG.requestDelay));
                
                const response = await fetch(url, {
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'MiningCalculator/1.0',
                        ...options.headers
                    },
                    ...options
                });
                
                if (!response.ok) {
                    if (response.status === 429) {
                        const waitTime = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                return data;
                
            } catch (error) {
                if (attempt === MINING_CONFIG.maxRetries) {
                    console.warn(`Request failed after ${MINING_CONFIG.maxRetries} attempts:`, error.message);
                    return null;
                }
                
                const waitTime = Math.pow(2, attempt) * 500;
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
}

// Initialize mining cache
const miningCache = new MiningCache();

// Get real-time coin data
async function getCoinData(coinId) {
    const cacheKey = miningCache.getKey('coin', { coinId });
    
    if (miningCache.isValid(cacheKey)) {
        return miningCache.get(cacheKey);
    }
    
    const url = `${MINING_CONFIG.coingeckoApi}/coins/${coinId}?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false`;
    const data = await miningCache.makeRequest(url);
    
    if (data) {
        miningCache.set(cacheKey, data);
    }
    
    return data;
}

// Get network difficulty and hashrate
async function getNetworkStats(coinId) {
    const algorithm = MINING_ALGORITHMS[coinId];
    if (!algorithm) return null;
    
    const cacheKey = miningCache.getKey('network', { coinId });
    
    if (miningCache.isValid(cacheKey)) {
        return miningCache.get(cacheKey);
    }
    
    let networkData = await getNetworkDataFromAPI(coinId, algorithm);
    
    if (!networkData) {
        // Fallback to estimated values based on coin data
        networkData = await estimateNetworkStats(coinId, algorithm);
    }
    
    if (networkData) {
        miningCache.set(cacheKey, networkData);
    }
    
    return networkData;
}

// Get network data from various APIs
async function getNetworkDataFromAPI(coinId, algorithm) {
    try {
        // Real network data based on coin
        switch (coinId) {
            case 'bitcoin':
                const btcDifficulty = await fetch('https://blockstream.info/api/blocks/tip/height')
                    .then(r => r.json())
                    .catch(() => null);
                
                if (btcDifficulty) {
                    const networkHashrate = (btcDifficulty * Math.pow(2, 32)) / 600; // H/s
                    return {
                        difficulty: btcDifficulty,
                        networkHashrate: networkHashrate / Math.pow(10, 12), // TH/s
                        blockTime: 600,
                        lastUpdate: Date.now()
                    };
                }
                break;
                
            case 'litecoin':
                // Estimate based on known network parameters
                return {
                    difficulty: 25000000,
                    networkHashrate: 600000, // MH/s estimated
                    blockTime: 150,
                    lastUpdate: Date.now()
                };
                
            case 'monero':
                // RandomX network estimation
                return {
                    difficulty: 350000000000,
                    networkHashrate: 2900000000, // H/s estimated
                    blockTime: 120,
                    lastUpdate: Date.now()
                };
                
            default:
                return null;
        }
    } catch (error) {
        console.warn(`Failed to get network data for ${coinId}:`, error.message);
        return null;
    }
}

// Estimate network stats based on market data
async function estimateNetworkStats(coinId, algorithm) {
    try {
        const coinData = await getCoinData(coinId);
        if (!coinData) return null;
        
        const marketCap = coinData.market_data.market_cap.usd;
        const price = coinData.market_data.current_price.usd;
        
        // Estimate network hashrate based on security budget (rough approximation)
        const dailyIssuance = (algorithm.blockReward * 86400) / algorithm.blockTime;
        const dailySecurityBudget = dailyIssuance * price * 0.7; // Assume 70% goes to mining
        
        let estimatedHashrate;
        switch (algorithm.algorithm) {
            case 'SHA-256':
                estimatedHashrate = (dailySecurityBudget / 86400) * 1000 / 0.05; // Rough TH/s
                break;
            case 'Ethash':
                estimatedHashrate = (dailySecurityBudget / 86400) * 100 / 0.3; // Rough MH/s
                break;
            case 'Scrypt':
                estimatedHashrate = (dailySecurityBudget / 86400) * 500 / 0.2; // Rough MH/s
                break;
            case 'RandomX':
                estimatedHashrate = (dailySecurityBudget / 86400) * 10000 / 0.1; // Rough H/s
                break;
            default:
                estimatedHashrate = 1000000; // Fallback
        }
        
        return {
            difficulty: estimatedHashrate * algorithm.blockTime / Math.pow(2, 16),
            networkHashrate: estimatedHashrate,
            blockTime: algorithm.blockTime,
            estimated: true,
            lastUpdate: Date.now()
        };
        
    } catch (error) {
        console.warn(`Failed to estimate network stats for ${coinId}:`, error.message);
        return null;
    }
}

// Calculate mining profitability
function calculateProfitability(userHashrate, powerConsumption, electricityCost, coinData, networkStats, algorithm) {
    if (!coinData || !networkStats || !algorithm) return null;
    
    const coinPrice = coinData.market_data.current_price.usd;
    const networkHashrate = networkStats.networkHashrate;
    const blockTime = networkStats.blockTime;
    const blockReward = algorithm.blockReward;
    
    // Handle special cases like Monero with dynamic emission
    let actualBlockReward = blockReward;
    if (algorithm.symbol === 'XMR') {
        // Monero tail emission: minimum 0.6 XMR per 2 minutes
        actualBlockReward = Math.max(0.6, blockReward);
    }
    
    // Calculate shares and rewards
    const userShareOfNetwork = userHashrate / networkHashrate;
    const blocksPerDay = 86400 / blockTime;
    const dailyBlocks = userShareOfNetwork * blocksPerDay;
    const dailyCoins = dailyBlocks * actualBlockReward;
    
    // Revenue calculations
    const dailyRevenue = dailyCoins * coinPrice;
    const hourlyRevenue = dailyRevenue / 24;
    const monthlyRevenue = dailyRevenue * 30;
    const yearlyRevenue = dailyRevenue * 365;
    
    // Cost calculations
    const dailyPowerCostKwh = (powerConsumption / 1000) * 24;
    const dailyPowerCost = dailyPowerCostKwh * electricityCost;
    const hourlyPowerCost = dailyPowerCost / 24;
    const monthlyPowerCost = dailyPowerCost * 30;
    const yearlyPowerCost = dailyPowerCost * 365;
    
    // Profit calculations
    const dailyProfit = dailyRevenue - dailyPowerCost;
    const hourlyProfit = hourlyRevenue - hourlyPowerCost;
    const monthlyProfit = monthlyRevenue - monthlyPowerCost;
    const yearlyProfit = yearlyRevenue - yearlyPowerCost;
    
    // Efficiency metrics
    const hashPerWatt = userHashrate / powerConsumption;
    const revenuePerKwh = dailyRevenue / dailyPowerCostKwh;
    const profitMargin = dailyRevenue > 0 ? (dailyProfit / dailyRevenue) * 100 : 0;
    
    // Break-even analysis (assuming hardware cost)
    const estimatedHardwareCost = estimateHardwareCost(algorithm.algorithm, userHashrate, powerConsumption);
    const breakEvenDays = dailyProfit > 0 ? Math.ceil(estimatedHardwareCost / dailyProfit) : Infinity;
    
    // Pool fees (estimated 1-2%)
    const poolFeePercent = 1.5;
    const dailyPoolFees = dailyRevenue * (poolFeePercent / 100);
    const netDailyProfit = dailyProfit - dailyPoolFees;
    
    return {
        // Coin and network info
        coinInfo: {
            symbol: algorithm.symbol,
            price: coinPrice,
            algorithm: algorithm.algorithm,
            networkHashrate: networkHashrate,
            difficulty: networkStats.difficulty,
            blockReward: actualBlockReward,
            blockTime: blockTime
        },
        
        // Mining output
        mining: {
            dailyCoins: dailyCoins,
            hourlyCoins: dailyCoins / 24,
            monthlyCoins: dailyCoins * 30,
            yearlyCoins: dailyCoins * 365,
            networkShare: userShareOfNetwork * 100
        },
        
        // Revenue
        revenue: {
            hourly: hourlyRevenue,
            daily: dailyRevenue,
            monthly: monthlyRevenue,
            yearly: yearlyRevenue
        },
        
        // Costs
        costs: {
            hourly: hourlyPowerCost,
            daily: dailyPowerCost,
            monthly: monthlyPowerCost,
            yearly: yearlyPowerCost,
            poolFeesDaily: dailyPoolFees,
            powerConsumption: dailyPowerCostKwh
        },
        
        // Profit
        profit: {
            hourly: hourlyProfit,
            daily: dailyProfit,
            monthly: monthlyProfit,
            yearly: yearlyProfit,
            netDaily: netDailyProfit,
            netMonthly: (netDailyProfit * 30)
        },
        
        // Metrics
        metrics: {
            hashPerWatt: hashPerWatt,
            revenuePerKwh: revenuePerKwh,
            profitMargin: profitMargin,
            breakEvenDays: breakEvenDays,
            estimatedHardwareCost: estimatedHardwareCost,
            isProfitable: netDailyProfit > 0
        }
    };
}

// Estimate hardware cost based on hashrate and efficiency
function estimateHardwareCost(algorithm, hashrate, power) {
    const hardware = MINING_HARDWARE[algorithm];
    if (!hardware || hardware.length === 0) return 5000; // Default estimate
    
    // Find closest hardware match
    const closest = hardware.reduce((prev, curr) => {
        const prevDiff = Math.abs(prev.hashrate - hashrate);
        const currDiff = Math.abs(curr.hashrate - hashrate);
        return currDiff < prevDiff ? curr : prev;
    });
    
    // Estimate cost based on hashrate scaling
    const basePrice = {
        'SHA-256': 3000,  // ASIC miners
        'Ethash': 1500,   // GPUs
        'Scrypt': 2500,   // Scrypt ASICs
        'RandomX': 800,   // CPUs
        'X11': 2000,      // X11 ASICs
        'Equihash': 1200  // Equihash miners
    };
    
    const pricePerUnit = basePrice[algorithm] || 1000;
    const unitRatio = hashrate / closest.hashrate;
    
    return pricePerUnit * unitRatio;
}

// Get hardware recommendations
function getHardwareRecommendations(algorithm) {
    const hardware = MINING_HARDWARE[algorithm];
    if (!hardware) return [];
    
    return hardware.slice(0, 3).map(hw => ({
        ...hw,
        estimatedPrice: estimateHardwareCost(algorithm, hw.hashrate, hw.power) / 2 // Per unit price
    }));
}

// Main mining calculator function
async function calculateMining() {
    const hashRateInput = document.getElementById('hashRate');
    const powerInput = document.getElementById('powerConsumption');
    const electricityInput = document.getElementById('electricityCost');
    const coinSelect = document.getElementById('miningCoin');
    const resultDiv = document.getElementById('miningResult');
    
    if (!hashRateInput || !powerInput || !electricityInput || !coinSelect || !resultDiv) {
        console.error('Required mining form elements not found');
        return;
    }
    
    const hashRate = parseFloat(hashRateInput.value);
    const powerConsumption = parseFloat(powerInput.value);
    const electricityCost = parseFloat(electricityInput.value);
    const coin = coinSelect.value.toLowerCase().trim();
    
    // Input validation
    if (!coin) {
        showResult('miningResult', 'Please select a cryptocurrency to mine', 'error');
        return;
    }
    
    if (!hashRate || !powerConsumption || !electricityCost ||
        hashRate <= 0 || powerConsumption <= 0 || electricityCost <= 0) {
        showResult('miningResult', 'Please enter valid positive values for all fields', 'error');
        return;
    }
    
    if (!MINING_ALGORITHMS[coin]) {
        showResult('miningResult', 'Selected cryptocurrency is not supported for mining calculations', 'error');
        return;
    }
    
    if (electricityCost > 1) {
        showResult('miningResult', 'Electricity cost seems high. Please check if you entered the correct value (USD per kWh)', 'error');
        return;
    }
    
    showResult('miningResult', 'Calculating mining profitability with real network data...', 'loading');
    
    try {
        const algorithm = MINING_ALGORITHMS[coin];
        
        // Fetch real-time data
        const [coinData, networkStats] = await Promise.all([
            getCoinData(coin),
            getNetworkStats(coin)
        ]);
        
        if (!coinData) {
            throw new Error('Unable to fetch current coin price data');
        }
        
        if (!networkStats) {
            throw new Error('Unable to fetch network mining statistics');
        }
        
        // Calculate profitability
        const results = calculateProfitability(
            hashRate,
            powerConsumption,
            electricityCost,
            coinData,
            networkStats,
            algorithm
        );
        
        if (!results) {
            throw new Error('Unable to calculate mining profitability');
        }
        
        // Get hardware recommendations
        const hardwareRecs = getHardwareRecommendations(algorithm.algorithm);
        
        // Format numbers
        const formatNumber = (num, decimals = 2) => {
            if (num === null || num === undefined || isNaN(num)) return 'N/A';
            if (num === Infinity) return '‚àû';
            if (Math.abs(num) > 1000000000) return (num / 1000000000).toFixed(1) + 'B';
            if (Math.abs(num) > 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (Math.abs(num) > 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toFixed(decimals);
        };
        
        const formatCurrency = (amount) => {
            if (amount === null || amount === undefined || isNaN(amount)) return 'N/A';
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 2,
                maximumFractionDigits: 6
            }).format(amount);
        };
        
        const formatHashrate = (rate, unit) => {
            if (rate === null || rate === undefined || isNaN(rate)) return 'N/A';
            return `${formatNumber(rate)} ${unit}`;
        };
        
        // Generate result HTML
        const result = `
            <div class="mining-result">
                <div class="mining-header">
                    <h3>${coinData.name} (${algorithm.symbol}) Mining Calculator</h3>
                    <div class="algorithm-badge">${algorithm.algorithm} Algorithm</div>
                </div>
                
                <div class="profitability-summary">
                    <div class="profit-status ${results.metrics.isProfitable ? 'profitable' : 'unprofitable'}">
                        ${results.metrics.isProfitable ? '‚úÖ PROFITABLE' : '‚ùå NOT PROFITABLE'}
                    </div>
                    <div class="daily-profit">
                        Daily Net Profit: <strong>${formatCurrency(results.profit.netDaily)}</strong>
                    </div>
                    <div class="profit-margin">
                        Profit Margin: <strong>${results.metrics.profitMargin.toFixed(1)}%</strong>
                    </div>
                </div>
                
                <div class="coin-network-info">
                    <h4>Network Information</h4>
                    <div class="network-grid">
                        <div class="network-item">
                            <span class="label">Current Price:</span>
                            <span class="value">${formatCurrency(results.coinInfo.price)}</span>
                        </div>
                        <div class="network-item">
                            <span class="label">Network Hashrate:</span>
                            <span class="value">${formatHashrate(results.coinInfo.networkHashrate, algorithm.hashRateUnit)}</span>
                        </div>
                        <div class="network-item">
                            <span class="label">Block Reward:</span>
                            <span class="value">${results.coinInfo.blockReward} ${algorithm.symbol}</span>
                        </div>
                        <div class="network-item">
                            <span class="label">Block Time:</span>
                            <span class="value">${results.coinInfo.blockTime}s</span>
                        </div>
                        <div class="network-item">
                            <span class="label">Your Network Share:</span>
                            <span class="value">${results.mining.networkShare.toFixed(8)}%</span>
                        </div>
                        ${networkStats.estimated ? `
                        <div class="network-item">
                            <span class="label">Data Type:</span>
                            <span class="value estimated">Estimated</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                
                <div class="mining-output">
                    <h4>Mining Output</h4>
                    <div class="output-grid">
                        <div class="output-period">
                            <div class="period-label">Hourly</div>
                            <div class="coins">${results.mining.hourlyCoins.toFixed(8)} ${algorithm.symbol}</div>
                            <div class="revenue">${formatCurrency(results.revenue.hourly)}</div>
                        </div>
                        <div class="output-period">
                            <div class="period-label">Daily</div>
                            <div class="coins">${results.mining.dailyCoins.toFixed(8)} ${algorithm.symbol}</div>
                            <div class="revenue">${formatCurrency(results.revenue.daily)}</div>
                        </div>
                        <div class="output-period">
                            <div class="period-label">Monthly</div>
                            <div class="coins">${results.mining.monthlyCoins.toFixed(6)} ${algorithm.symbol}</div>
                            <div class="revenue">${formatCurrency(results.revenue.monthly)}</div>
                        </div>
                        <div class="output-period">
                            <div class="period-label">Yearly</div>
                            <div class="coins">${results.mining.yearlyCoins.toFixed(4)} ${algorithm.symbol}</div>
                            <div class="revenue">${formatCurrency(results.revenue.yearly)}</div>
                        </div>
                    </div>
                </div>
                
                <div class="costs-breakdown">
                    <h4>Cost Analysis</h4>
                    <div class="costs-grid">
                        <div class="cost-item">
                            <span class="label">Power Consumption:</span>
                            <span class="value">${results.costs.powerConsumption.toFixed(2)} kWh/day</span>
                        </div>
                        <div class="cost-item">
                            <span class="label">Daily Power Cost:</span>
                            <span class="value">${formatCurrency(results.costs.daily)}</span>
                        </div>
                        <div class="cost-item">
                            <span class="label">Monthly Power Cost:</span>
                            <span class="value">${formatCurrency(results.costs.monthly)}</span>
                        </div>
                        <div class="cost-item">
                            <span class="label">Pool Fees (1.5%):</span>
                            <span class="value">${formatCurrency(results.costs.poolFeesDaily)}/day</span>
                        </div>
                        <div class="cost-item">
                            <span class="label">Total Daily Costs:</span>
                            <span class="value">${formatCurrency(results.costs.daily + results.costs.poolFeesDaily)}</span>
                        </div>
                    </div>
                </div>
                
                <div class="profit-breakdown">
                    <h4>Profit Breakdown</h4>
                    <div class="profit-grid">
                        <div class="profit-item">
                            <span class="label">Hourly Profit:</span>
                            <span class="value ${results.profit.hourly >= 0 ? 'positive' : 'negative'}">
                                ${formatCurrency(results.profit.hourly)}
                            </span>
                        </div>
                        <div class="profit-item">
                            <span class="label">Daily Profit (Gross):</span>
                            <span class="value ${results.profit.daily >= 0 ? 'positive' :
							<span class="value positive">
                                ${formatCurrency(results.profit.daily)}
                            </span>
                        </div>
                        <div class="profit-item">
                            <span class="label">Daily Profit (Net):</span>
                            <span class="value ${results.profit.netDaily >= 0 ? 'positive' : 'negative'}">
                                ${formatCurrency(results.profit.netDaily)}
                            </span>
                        </div>
                        <div class="profit-item">
                            <span class="label">Monthly Profit (Net):</span>
                            <span class="value ${results.profit.netMonthly >= 0 ? 'positive' : 'negative'}">
                                ${formatCurrency(results.profit.netMonthly)}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="efficiency-metrics">
                    <h4>Efficiency Metrics</h4>
                    <div class="metrics-grid">
                        <div class="metric-item">
                            <span class="label">Hash per Watt:</span>
                            <span class="value">${formatNumber(results.metrics.hashPerWatt, 4)} ${algorithm.hashRateUnit}/W</span>
                        </div>
                        <div class="metric-item">
                            <span class="label">Revenue per kWh:</span>
                            <span class="value">${formatCurrency(results.metrics.revenuePerKwh)}</span>
                        </div>
                        <div class="metric-item">
                            <span class="label">Hardware ROI:</span>
                            <span class="value">
                                ${results.metrics.breakEvenDays === Infinity ? 'Never' : `${results.metrics.breakEvenDays} days`}
                            </span>
                        </div>
                        <div class="metric-item">
                            <span class="label">Est. Hardware Cost:</span>
                            <span class="value">${formatCurrency(results.metrics.estimatedHardwareCost)}</span>
                        </div>
                    </div>
                </div>
                
                ${hardwareRecs.length > 0 ? `
                <div class="hardware-recommendations">
                    <h4>Recommended Hardware for ${algorithm.algorithm}</h4>
                    <div class="hardware-grid">
                        ${hardwareRecs.map(hw => `
                            <div class="hardware-card">
                                <div class="hardware-name">${hw.name}</div>
                                <div class="hardware-specs">
                                    <div>Hashrate: ${formatHashrate(hw.hashrate, algorithm.hashRateUnit)}</div>
                                    <div>Power: ${hw.power}W</div>
                                    <div>Efficiency: ${hw.efficiency} W/${algorithm.hashRateUnit}</div>
                                    <div>Est. Price: ${formatCurrency(hw.estimatedPrice)}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}
                
                <div class="mining-warnings">
                    <h4>‚ö†Ô∏è Important Considerations</h4>
                    <ul>
                        <li>Mining profitability is highly volatile and depends on coin price, network difficulty, and electricity costs</li>
                        <li>Network difficulty adjusts regularly, which will affect your earnings</li>
                        <li>Pool fees typically range from 1-3% of earnings</li>
                        <li>Hardware depreciation and maintenance costs are not included</li>
                        <li>Consider local regulations and tax implications</li>
                        ${networkStats.estimated ? '<li><strong>Network data is estimated - actual results may vary</strong></li>' : ''}
                        ${coin === 'ethereum' ? '<li><strong>Ethereum has moved to Proof of Stake - mining is no longer possible</strong></li>' : ''}
                    </ul>
                </div>
                
                <div class="calculation-timestamp">
                    <small>Last updated: ${new Date().toLocaleString()}</small>
                    ${networkStats.estimated ? '<br><small>‚ö†Ô∏è Using estimated network data</small>' : ''}
                </div>
            </div>
        `;
        
        showResult('miningResult', result, 'success');
        
    } catch (error) {
        console.error('Mining calculation error:', error);
        showResult('miningResult', `Error calculating mining profitability: ${error.message}`, 'error');
    }
}

// Update coin selection and hashrate unit
function updateMiningCoinInfo() {
    const coinSelect = document.getElementById('miningCoin');
    const hashRateLabel = document.getElementById('hashRateLabel');
    
    if (!coinSelect || !hashRateLabel) return;
    
    const selectedCoin = coinSelect.value.toLowerCase().trim();
    const algorithm = MINING_ALGORITHMS[selectedCoin];
    
    if (algorithm) {
        hashRateLabel.textContent = `Hash Rate (${algorithm.hashRateUnit}):`;
        
        // Update placeholder based on algorithm
        const hashRateInput = document.getElementById('hashRate');
        if (hashRateInput) {
            let placeholder;
            switch (algorithm.hashRateUnit) {
                case 'TH/s':
                    placeholder = 'e.g., 100 (for 100 TH/s)';
                    break;
                case 'MH/s':
                    placeholder = 'e.g., 500 (for 500 MH/s)';
                    break;
                case 'GH/s':
                    placeholder = 'e.g., 1000 (for 1000 GH/s)';
                    break;
                case 'H/s':
                    placeholder = 'e.g., 15000 (for 15000 H/s)';
                    break;
                case 'Sol/s':
                    placeholder = 'e.g., 500 (for 500 Sol/s)';
                    break;
                default:
                    placeholder = 'Enter your hashrate';
            }
            hashRateInput.placeholder = placeholder;
        }
    }
}

// Initialize mining calculator when page loads
document.addEventListener('DOMContentLoaded', function() {
    const coinSelect = document.getElementById('miningCoin');
    
    if (coinSelect) {
        // Populate coin options
        Object.keys(MINING_ALGORITHMS).forEach(coinId => {
            const algorithm = MINING_ALGORITHMS[coinId];
            const option = document.createElement('option');
            option.value = coinId;
            option.textContent = `${coinId.charAt(0).toUpperCase() + coinId.slice(1).replace('-', ' ')} (${algorithm.symbol}) - ${algorithm.algorithm}`;
            coinSelect.appendChild(option);
        });
        
        // Add event listener for coin selection change
        coinSelect.addEventListener('change', updateMiningCoinInfo);
        
        // Initialize with first option
        if (coinSelect.options.length > 1) {
            coinSelect.selectedIndex = 1; // Skip empty option
            updateMiningCoinInfo();
        }
    }
    
    // Add calculate button event listener
    const calculateBtn = document.getElementById('calculateMining');
    if (calculateBtn) {
        calculateBtn.addEventListener('click', calculateMining);
    }
});

// Enhanced Paper Wallet Generator with Real Data
async function generateWallet() {
    const coinId = document.getElementById('walletCoin').value;
    const count = parseInt(document.getElementById('walletCount').value);
    
    // Validation
    if (!count || count <= 0 || count > 10) {
        showResult('paperwalletResult', 'Please enter a valid number of wallets (1-10)', 'error');
        return;
    }

    // Show loading state
    showResult('paperwalletResult', 'Generating wallets and fetching real market data...', 'loading');

    try {
        // Fetch real cryptocurrency data from CoinGecko API
        const coinData = await fetchCoinData(coinId);
        
        if (!coinData) {
            showResult('paperwalletResult', `Cryptocurrency "${coinId}" not found. Please check the coin ID and try again.`, 'error');
            return;
        }

        // Fetch current market data
        const marketData = await fetchMarketData(coinId);
        
        let result = `
            <div style="border: 2px solid #00d4ff; border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; background: rgba(0, 212, 255, 0.05);">
                <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                    <img src="${coinData.image.large}" alt="${coinData.name}" width="48" height="48" style="border-radius: 50%;">
                    <div>
                        <h3 style="color: #00d4ff; margin: 0;">${coinData.name} (${coinData.symbol.toUpperCase()})</h3>
                        <p style="margin: 0; opacity: 0.8;">Current Price: $${formatPrice(marketData.current_price.usd)}</p>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="color: #00d4ff; font-size: 1.2rem; font-weight: bold;">$${formatPrice(marketData.current_price.usd)}</div>
                        <div style="opacity: 0.8;">Current Price</div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="color: ${marketData.price_change_percentage_24h >= 0 ? '#4ade80' : '#f87171'}; font-size: 1.2rem; font-weight: bold;">
                            ${marketData.price_change_percentage_24h >= 0 ? '+' : ''}${marketData.price_change_percentage_24h.toFixed(2)}%
                        </div>
                        <div style="opacity: 0.8;">24h Change</div>
                    </div>
                    <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px; text-align: center;">
                        <div style="color: #00d4ff; font-size: 1.2rem; font-weight: bold;">#${coinData.market_cap_rank || 'N/A'}</div>
                        <div style="opacity: 0.8;">Market Rank</div>
                    </div>
                </div>
            </div>
        `;

        result += `<div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px; margin-bottom: 1rem;">`;
        result += `<h4 style="color: #00d4ff; margin-top: 0;">Generated ${count} ${coinData.symbol.toUpperCase()} Paper Wallet(s):</h4>`;
        
        // Generate wallets with proper format for each cryptocurrency
        for (let i = 1; i <= count; i++) {
            const walletData = generateCryptoWallet(coinData.symbol.toLowerCase());
            
            result += `
                <div style="background: rgba(0, 0, 0, 0.3); padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem; border-left: 4px solid #00d4ff;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 1rem;">
                        <strong style="color: #00d4ff; font-size: 1.1rem;">Wallet #${i}</strong>
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="copyToClipboard('${walletData.address}')" style="background: rgba(0, 212, 255, 0.2); border: 1px solid #00d4ff; color: #00d4ff; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Copy Address</button>
                            <button onclick="copyToClipboard('${walletData.privateKey}')" style="background: rgba(255, 107, 107, 0.2); border: 1px solid #ff6b6b; color: #ff6b6b; padding: 0.25rem 0.5rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">Copy Private Key</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: #00d4ff;">Public Address:</div>
                        <div style="background: rgba(0, 0, 0, 0.5); padding: 0.75rem; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.9rem; word-break: break-all; border: 1px solid rgba(255, 255, 255, 0.1);">
                            ${walletData.address}
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: #ff6b6b;">Private Key:</div>
                        <div style="background: rgba(0, 0, 0, 0.5); padding: 0.75rem; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.9rem; word-break: break-all; border: 1px solid rgba(255, 107, 107, 0.2);">
                            ${walletData.privateKey}
                        </div>
                    </div>

                    <div style="background: rgba(0, 212, 255, 0.1); padding: 1rem; border-radius: 6px; font-size: 0.9rem;">
                        <strong>Wallet Information:</strong><br>
                        ‚Ä¢ Network: ${walletData.network}<br>
                        ‚Ä¢ Format: ${walletData.format}<br>
                        ‚Ä¢ Generated: ${new Date().toLocaleString()}<br>
                        ‚Ä¢ Derivation Path: ${walletData.derivationPath || 'Standard'}
                    </div>
                </div>
            `;
        }
        
        result += `</div>`;

        // Add comprehensive security warnings and best practices
        result += `
            <div style="background: rgba(255, 107, 107, 0.1); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255, 107, 107, 0.3); margin-bottom: 1rem;">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <strong style="color: #ff6b6b; font-size: 1.1rem;">CRITICAL SECURITY WARNING</strong>
                </div>
                <div style="font-size: 0.95rem; line-height: 1.6;">
                    <p><strong>These are DEMO wallets for educational and testing purposes only!</strong></p>
                    <p><strong>NEVER send real ${coinData.symbol.toUpperCase()} to these addresses!</strong></p>
                    
                    <div style="margin-top: 1rem;">
                        <strong>For real wallet generation:</strong><br>
                        ‚Ä¢ Use official wallet software from ${coinData.name}'s official website<br>
                        ‚Ä¢ Generate wallets on an offline, air-gapped computer<br>
                        ‚Ä¢ Use hardware wallets for large amounts<br>
                        ‚Ä¢ Never share your private keys with anyone<br>
                        ‚Ä¢ Store backup phrases securely and offline
                    </div>
                </div>
            </div>
        `;

        // Add live market analysis
        const analysis = generateMarketAnalysis(marketData, coinData);
        result += `
            <div style="background: rgba(255, 255, 255, 0.05); padding: 1.5rem; border-radius: 12px;">
                <h4 style="color: #00d4ff; margin-top: 0;">Live Market Analysis for ${coinData.name}</h4>
                ${analysis}
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(0, 212, 255, 0.1); border-radius: 8px; font-size: 0.9rem;">
                    <strong>Data provided by CoinGecko API</strong><br>
                    Last updated: ${new Date().toLocaleString()}<br>
                    Market data refreshed every 60 seconds
                </div>
            </div>
        `;

        showResult('paperwalletResult', result);

    } catch (error) {
        console.error('Error generating wallet:', error);
        showResult('paperwalletResult', `Error: Failed to fetch real-time data. Please check your connection and try again. (${error.message})`, 'error');
    }
}

// Fetch real cryptocurrency data from CoinGecko API
async function fetchCoinData(coinId) {
    try {
        const response = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}?localization=false&tickers=false&market_data=false&community_data=false&developer_data=false&sparkline=false`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error('Failed to fetch coin data:', error);
        return null;
    }
}

// Fetch real market data from CoinGecko API
async function fetchMarketData(coinId) {
    try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true&include_24hr_vol=true`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        return data[coinId];
    } catch (error) {
        console.error('Failed to fetch market data:', error);
        return { current_price: { usd: 0 }, price_change_percentage_24h: 0 };
    }
}

// Generate realistic wallet addresses based on cryptocurrency type
function generateCryptoWallet(symbol) {
    const wallets = {
        'btc': {
            address: generateBitcoinAddress(),
            privateKey: generateBitcoinPrivateKey(),
            network: 'Bitcoin Mainnet',
            format: 'P2PKH (Legacy)',
            derivationPath: "m/44'/0'/0'/0/0"
        },
        'eth': {
            address: generateEthereumAddress(),
            privateKey: generateEthereumPrivateKey(),
            network: 'Ethereum Mainnet',
            format: 'EIP-55 Checksum',
            derivationPath: "m/44'/60'/0'/0/0"
        },
        'ltc': {
            address: generateLitecoinAddress(),
            privateKey: generateLitecoinPrivateKey(),
            network: 'Litecoin Mainnet',
            format: 'P2PKH (Legacy)',
            derivationPath: "m/44'/2'/0'/0/0"
        },
        'ada': {
            address: generateCardanoAddress(),
            privateKey: generateCardanoPrivateKey(),
            network: 'Cardano Mainnet',
            format: 'Bech32 (Shelley Era)',
            derivationPath: "m/1852'/1815'/0'/0/0"
        },
        'default': {
            address: generateGenericAddress(),
            privateKey: generateGenericPrivateKey(),
            network: 'Generic Network',
            format: 'Standard Format',
            derivationPath: "m/44'/0'/0'/0/0"
        }
    };

    return wallets[symbol] || wallets['default'];
}

// Bitcoin address generation (demo format)
function generateBitcoinAddress() {
    const prefixes = ['1', '3', 'bc1'];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    
    if (prefix === 'bc1') {
        // Bech32 format
        const chars = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
        let address = 'bc1q';
        for (let i = 0; i < 39; i++) {
            address += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return address;
    } else {
        // Legacy format
        const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let address = prefix;
        const length = prefix === '1' ? 33 : 34;
        for (let i = 1; i < length; i++) {
            address += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return address;
    }
}

// Ethereum address generation (demo format)
function generateEthereumAddress() {
    const chars = '0123456789abcdef';
    let address = '0x';
    for (let i = 0; i < 40; i++) {
        address += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    // Apply EIP-55 checksum (simplified)
    return address.toLowerCase().replace(/[a-f]/g, (char, index) => {
        return Math.random() > 0.5 ? char.toUpperCase() : char;
    });
}

// Litecoin address generation (demo format)
function generateLitecoinAddress() {
    const prefixes = ['L', 'M', 'ltc1'];
    const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
    
    if (prefix === 'ltc1') {
        const chars = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
        let address = 'ltc1q';
        for (let i = 0; i < 38; i++) {
            address += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return address;
    } else {
        const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let address = prefix;
        for (let i = 1; i < 34; i++) {
            address += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return address;
    }
}

// Cardano address generation (demo format)
function generateCardanoAddress() {
    const chars = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
    let address = 'addr1';
    for (let i = 0; i < 100; i++) {
        address += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return address;
}

// Generic address generation
function generateGenericAddress() {
    const chars = '0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let address = '';
    for (let i = 0; i < 35; i++) {
        address += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return address;
}

// Private key generation functions
function generateBitcoinPrivateKey() {
    return generateHexString(64); // 32 bytes
}

function generateEthereumPrivateKey() {
    return '0x' + generateHexString(64); // 32 bytes
}

function generateLitecoinPrivateKey() {
    return generateHexString(64); // 32 bytes
}

function generateCardanoPrivateKey() {
    return generateHexString(128); // 64 bytes
}

function generateGenericPrivateKey() {
    return generateHexString(64); // 32 bytes
}

function generateHexString(length) {
    const chars = '0123456789abcdef';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// Market analysis generator
function generateMarketAnalysis(marketData, coinData) {
    const price = marketData.current_price?.usd || 0;
    const change24h = marketData.price_change_percentage_24h || 0;
    const marketCap = marketData.market_cap?.usd || 0;
    const volume = marketData.total_volume?.usd || 0;
    
    let analysis = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">';
    
    // Price trend analysis
    const trend = change24h >= 5 ? 'Strongly Bullish' : 
                  change24h >= 1 ? 'Bullish' : 
                  change24h >= -1 ? 'Neutral' : 
                  change24h >= -5 ? 'Bearish' : 'Strongly Bearish';
    
    const trendColor = change24h >= 1 ? '#4ade80' : change24h >= -1 ? '#fbbf24' : '#f87171';
    
    analysis += `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
            <div style="color: ${trendColor}; font-weight: bold;">${trend}</div>
            <div style="opacity: 0.8; font-size: 0.9rem;">24h Trend</div>
        </div>
    `;
    
    // Market cap
    analysis += `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
            <div style="color: #00d4ff; font-weight: bold;">$${formatLargeNumber(marketCap)}</div>
            <div style="opacity: 0.8; font-size: 0.9rem;">Market Cap</div>
        </div>
    `;
    
    // Volume
    analysis += `
        <div style="background: rgba(255, 255, 255, 0.05); padding: 1rem; border-radius: 8px;">
            <div style="color: #00d4ff; font-weight: bold;">$${formatLargeNumber(volume)}</div>
            <div style="opacity: 0.8; font-size: 0.9rem;">24h Volume</div>
        </div>
    `;
    
    analysis += '</div>';
    
    return analysis;
}

// Utility functions
function formatPrice(price) {
    if (!price) return '0.00';
    return new Intl.NumberFormat('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: price < 1 ? 8 : 2
    }).format(price);
}

function formatLargeNumber(num) {
    if (!num) return '0';
    if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
    if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
    return num.toFixed(2);
}

function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        // Show temporary success message
        const originalText = event.target.textContent;
        event.target.textContent = 'Copied!';
        event.target.style.background = 'rgba(74, 222, 128, 0.3)';
        
        setTimeout(() => {
            event.target.textContent = originalText;
            event.target.style.background = '';
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy text: ', err);
        alert('Failed to copy to clipboard');
    });
}

function showResult(elementId, content, type = 'success') {
    const element = document.getElementById(elementId);
    if (element) {
        element.innerHTML = content;
        element.className = `result show ${type}`;
        element.style.display = 'block';
    }
}

// Enhanced cryptographically secure private key generation
function generateRandomPrivateKey(cryptocurrency = 'bitcoin') {
    // Use crypto.getRandomValues for cryptographically secure random generation
    const getSecureRandomBytes = (length) => {
        if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
            const array = new Uint8Array(length);
            crypto.getRandomValues(array);
            return Array.from(array);
        } else {
            // Fallback for older browsers (less secure)
            const bytes = [];
            for (let i = 0; i < length; i++) {
                bytes.push(Math.floor(Math.random() * 256));
            }
            return bytes;
        }
    };

    const cryptoSpecs = {
        bitcoin: { keyLength: 32, format: 'hex', prefix: '' },
        ethereum: { keyLength: 32, format: 'hex', prefix: '0x' },
        litecoin: { keyLength: 32, format: 'hex', prefix: '' },
        cardano: { keyLength: 64, format: 'hex', prefix: '' },
        solana: { keyLength: 32, format: 'base58', prefix: '' },
        polygon: { keyLength: 32, format: 'hex', prefix: '0x' },
        chainlink: { keyLength: 32, format: 'hex', prefix: '0x' },
        polkadot: { keyLength: 32, format: 'hex', prefix: '0x' }
    };

    const spec = cryptoSpecs[cryptocurrency.toLowerCase()] || cryptoSpecs.bitcoin;
    const randomBytes = getSecureRandomBytes(spec.keyLength);
    
    if (spec.format === 'hex') {
        const hexKey = randomBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');
        return spec.prefix + hexKey;
    } else if (spec.format === 'base58') {
        // Simplified base58 encoding for demo
        const base58Chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        let key = '';
        for (let i = 0; i < 44; i++) { // Solana private keys are typically 44 characters in base58
            key += base58Chars.charAt(Math.floor(Math.random() * base58Chars.length));
        }
        return key;
    }
    
    return randomBytes.map(byte => byte.toString(16).padStart(2, '0')).join('');
}

// Enhanced result display with animations and better error handling
function showResult(elementId, content, type = 'success') {
    const resultElement = document.getElementById(elementId);
    
    if (!resultElement) {
        console.error(`Element with ID '${elementId}' not found`);
        return;
    }

    // Add loading animation removal
    const loadingElement = document.querySelector(`#${elementId.replace('Result', 'Loading')}`);
    if (loadingElement) {
        loadingElement.classList.remove('show');
    }

    // Enhanced type handling with professional styling
    const typeStyles = {
        success: { class: 'result-success', icon: '‚úÖ' },
        error: { class: 'result-error', icon: '‚ùå' },
        warning: { class: 'result-warning', icon: '‚ö†Ô∏è' },
        info: { class: 'result-info', icon: '‚ÑπÔ∏è' },
        loading: { class: 'result-loading', icon: '‚è≥' }
    };

    const typeConfig = typeStyles[type] || typeStyles.success;
    
    // Add timestamp to results
    const timestamp = new Date().toLocaleString('en-US', {
        timeZone: 'UTC',
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
    });

    const enhancedContent = `
        <div class="result-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
            <span style="display: flex; align-items: center; gap: 0.5rem;">
                <span>${typeConfig.icon}</span>
                <strong style="text-transform: capitalize;">${type}</strong>
            </span>
            <small style="opacity: 0.7; font-size: 0.8rem;">${timestamp}</small>
        </div>
        <div class="result-content">
            ${content}
        </div>
    `;

    resultElement.innerHTML = enhancedContent;
    resultElement.className = `result show ${typeConfig.class}`;
    
    // Add smooth entrance animation
    resultElement.style.opacity = '0';
    resultElement.style.transform = 'translateY(10px)';
    
    setTimeout(() => {
        resultElement.style.transition = 'all 0.3s ease';
        resultElement.style.opacity = '1';
        resultElement.style.transform = 'translateY(0)';
    }, 10);

    // Auto-hide success messages after 10 seconds
    if (type === 'success' && !content.includes('wallet') && !content.includes('Portfolio')) {
        setTimeout(() => {
            resultElement.style.transition = 'all 0.3s ease';
            resultElement.style.opacity = '0';
            setTimeout(() => {
                resultElement.classList.remove('show');
            }, 300);
        }, 10000);
    }
}

// Professional API client for CoinGecko with caching and error handling
class CoinGeckoAPIClient {
    constructor() {
        this.baseURL = 'https://api.coingecko.com/api/v3';
        this.cache = new Map();
        this.cacheTimeout = 60000; // 1 minute cache
        this.requestQueue = [];
        this.isProcessingQueue = false;
        this.lastRequestTime = 0;
        this.minRequestInterval = 1000; // 1 second between requests to respect rate limits
    }

    async makeRequest(endpoint, useCache = true) {
        const cacheKey = endpoint;
        
        // Check cache first
        if (useCache && this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < this.cacheTimeout) {
                return cached.data;
            }
        }

        return new Promise((resolve, reject) => {
            this.requestQueue.push({ endpoint, resolve, reject, cacheKey });
            this.processQueue();
        });
    }

    async processQueue() {
        if (this.isProcessingQueue || this.requestQueue.length === 0) {
            return;
        }

        this.isProcessingQueue = true;

        while (this.requestQueue.length > 0) {
            const request = this.requestQueue.shift();
            
            try {
                // Rate limiting
                const timeSinceLastRequest = Date.now() - this.lastRequestTime;
                if (timeSinceLastRequest < this.minRequestInterval) {
                    await new Promise(resolve => setTimeout(resolve, this.minRequestInterval - timeSinceLastRequest));
                }

                const response = await fetch(`${this.baseURL}${request.endpoint}`);
                this.lastRequestTime = Date.now();

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                // Cache the response
                this.cache.set(request.cacheKey, {
                    data: data,
                    timestamp: Date.now()
                });

                request.resolve(data);

            } catch (error) {
                console.error(`API request failed for ${request.endpoint}:`, error);
                request.reject(error);
            }

            // Small delay between requests
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        this.isProcessingQueue = false;
    }

    // Get current prices for multiple cryptocurrencies
    async getPrices(coinIds, currencies = 'usd', includeMarketData = true) {
        const params = new URLSearchParams({
            ids: Array.isArray(coinIds) ? coinIds.join(',') : coinIds,
            vs_currencies: currencies,
            include_market_cap: includeMarketData,
            include_24hr_vol: includeMarketData,
            include_24hr_change: includeMarketData,
            include_last_updated_at: true
        });

        return this.makeRequest(`/simple/price?${params}`);
    }

    // Get detailed coin information
    async getCoinDetails(coinId) {
        return this.makeRequest(`/coins/${coinId}?localization=false&tickers=false&community_data=false&developer_data=false&sparkline=false`);
    }

    // Get market data for top cryptocurrencies
    async getMarketData(limit = 250, page = 1) {
        return this.makeRequest(`/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${limit}&page=${page}&sparkline=false`);
    }

    // Get global cryptocurrency statistics
    async getGlobalStats() {
        return this.makeRequest('/global');
    }

    // Clear cache
    clearCache() {
        this.cache.clear();
    }
}

// Initialize API client
const apiClient = new CoinGeckoAPIClient();

// Enhanced price ticker with real-time data and error recovery
async function updatePriceTicker() {
    const tickerElement = document.getElementById('priceTicker');
    const statusElement = document.getElementById('ticker-status');
    
    if (!tickerElement) return;

    try {
        // Show loading state
        if (statusElement) {
            statusElement.textContent = 'üîÑ Updating...';
            statusElement.className = 'ticker-status loading';
        }

        // Fetch real-time data for popular cryptocurrencies
        const coinIds = [
            'bitcoin', 'ethereum', 'cardano', 'solana', 'polkadot', 
            'chainlink', 'litecoin', 'polygon', 'avalanche-2', 'cosmos'
        ];

        const data = await apiClient.getPrices(coinIds, 'usd', true);
        
        let tickerHTML = '';
        
        for (const coinId of coinIds) {
            if (data[coinId]) {
                const coinData = data[coinId];
                const price = coinData.usd;
                const change = coinData.usd_24h_change;
                const marketCap = coinData.usd_market_cap;
                const volume = coinData.usd_24h_vol;
                
                const changeClass = change >= 0 ? 'price-positive' : 'price-negative';
                const changeSymbol = change >= 0 ? '+' : '';
                const changeIcon = change >= 0 ? 'üìà' : 'üìâ';
                
                // Format large numbers
                const formatLargeNumber = (num) => {
                    if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
                    if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
                    if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
                    return num.toFixed(2);
                };

                tickerHTML += `
                    <div class="ticker-item" data-coin="${coinId}">
                        <div class="ticker-main">
                            <strong style="color: #00d4ff;">${coinId.toUpperCase().replace('-', ' ')}:</strong>
                            <span class="price">$${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: price < 1 ? 6 : 2 })}</span>
                            <span class="${changeClass}" title="24h Change">
                                ${changeIcon} ${changeSymbol}${Math.abs(change).toFixed(2)}%
                            </span>
                        </div>
                        <div class="ticker-details" style="font-size: 0.8rem; opacity: 0.7; margin-top: 2px;">
                            MC: $${formatLargeNumber(marketCap)} | Vol: $${formatLargeNumber(volume)}
                        </div>
                    </div>
                `;
            }
        }
        
        tickerElement.innerHTML = tickerHTML;
        
        // Update status
        if (statusElement) {
            statusElement.textContent = `‚úÖ Updated ${new Date().toLocaleTimeString()}`;
            statusElement.className = 'ticker-status success';
        }

        // Store last successful update
        localStorage.setItem('lastTickerUpdate', Date.now().toString());
        
    } catch (error) {
        console.error('Error updating price ticker:', error);
        
        if (statusElement) {
            statusElement.textContent = '‚ùå Update failed';
            statusElement.className = 'ticker-status error';
        }

        // Try to load cached data if available
        const lastUpdate = localStorage.getItem('lastTickerUpdate');
        const cachedData = localStorage.getItem('cachedTickerData');
        
        if (lastUpdate && cachedData && (Date.now() - parseInt(lastUpdate)) < 300000) { // 5 minutes
            tickerElement.innerHTML = cachedData + 
                '<div style="text-align: center; padding: 10px; color: #ff6b6b; font-size: 0.8rem;">‚ö†Ô∏è Showing cached data due to connection issues</div>';
        } else {
            tickerElement.innerHTML = `
                <div class="ticker-error" style="text-align: center; padding: 20px; color: #ff6b6b;">
                    <div>‚ùå Failed to load market data</div>
                    <div style="font-size: 0.8rem; margin-top: 5px;">Check your connection and try refreshing</div>
                    <button onclick="updatePriceTicker()" style="margin-top: 10px; padding: 5px 10px; background: rgba(255,107,107,0.2); border: 1px solid #ff6b6b; color: #ff6b6b; border-radius: 5px; cursor: pointer;">
                        üîÑ Retry
                    </button>
                </div>
            `;
        }
    }
}

// Enhanced input validation with cryptocurrency-specific rules
function addInputValidation() {
    const numberInputs = document.querySelectorAll('input[type="number"]');
    const textInputs = document.querySelectorAll('input[type="text"]');
    
    // Enhanced number input validation
    numberInputs.forEach(input => {
        // Add real-time validation feedback
        const createFeedback = (input) => {
            let feedback = input.parentNode.querySelector('.input-feedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.className = 'input-feedback';
                feedback.style.cssText = `
                    font-size: 0.8rem;
                    margin-top: 4px;
                    min-height: 1.2rem;
                    transition: all 0.2s ease;
                `;
                input.parentNode.appendChild(feedback);
            }
            return feedback;
        };

        const validateNumber = (value, input) => {
            const feedback = createFeedback(input);
            const min = parseFloat(input.getAttribute('min')) || 0;
            const max = parseFloat(input.getAttribute('max')) || Infinity;
            const step = parseFloat(input.getAttribute('step')) || 1;
            
            if (!value) {
                feedback.textContent = '';
                input.style.borderColor = '';
                return true;
            }

            const numValue = parseFloat(value);
            
            if (isNaN(numValue)) {
                feedback.textContent = '‚ùå Invalid number format';
                feedback.style.color = '#ff6b6b';
                input.style.borderColor = '#ff6b6b';
                return false;
            }

            if (numValue < min) {
                feedback.textContent = `‚ùå Minimum value: ${min}`;
                feedback.style.color = '#ff6b6b';
                input.style.borderColor = '#ff6b6b';
                return false;
            }

            if (numValue > max) {
                feedback.textContent = `‚ùå Maximum value: ${max}`;
                feedback.style.color = '#ff6b6b';
                input.style.borderColor = '#ff6b6b';
                return false;
            }

            if (step < 1 && step > 0) {
                const decimalPlaces = (step.toString().split('.')[1] || '').length;
                const valueDecimalPlaces = (value.split('.')[1] || '').length;
                if (valueDecimalPlaces > decimalPlaces) {
                    feedback.textContent = `‚ÑπÔ∏è Max ${decimalPlaces} decimal places`;
                    feedback.style.color = '#fbbf24';
                    input.style.borderColor = '#fbbf24';
                    return false;
                }
            }

            feedback.textContent = '‚úÖ Valid amount';
            feedback.style.color = '#4ade80';
            input.style.borderColor = '#4ade80';
            return true;
        };

        // Enhanced keypress validation
        input.addEventListener('keypress', function(e) {
            const allowedKeys = ['Backspace', 'Delete', 'Tab', 'Enter', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
            const allowedChars = /[0-9.]/;
            
            if (allowedKeys.includes(e.key)) return;
            
            if (!allowedChars.test(e.key)) {
                e.preventDefault();
                return;
            }

            // Prevent multiple decimal points
            if (e.key === '.' && this.value.includes('.')) {
                e.preventDefault();
            }
        });
        
        // Enhanced input validation
        input.addEventListener('input', function(e) {
            let value = this.value;
            
            // Remove invalid characters
            value = value.replace(/[^0-9.]/g, '');
            
            // Handle multiple decimal points
            const parts = value.split('.');
            if (parts.length > 2) {
                value = parts[0] + '.' + parts.slice(1).join('');
            }
            
            this.value = value;
            validateNumber(value, this);
        });

        // Validation on blur
        input.addEventListener('blur', function(e) {
            validateNumber(this.value, this);
        });
    });

    // Enhanced text input validation for cryptocurrency symbols
    textInputs.forEach(input => {
        if (input.placeholder && (input.placeholder.includes('bitcoin') || input.placeholder.includes('symbol'))) {
            input.addEventListener('input', function(e) {
                let value = this.value.toLowerCase().trim();
                
                // Remove invalid characters for crypto symbols
                value = value.replace(/[^a-z0-9-]/g, '');
                
                this.value = value;
                
                // Real-time validation feedback
                const feedback = input.parentNode.querySelector('.input-feedback') || 
                    (() => {
                        const div = document.createElement('div');
                        div.className = 'input-feedback';
                        div.style.cssText = 'font-size: 0.8rem; margin-top: 4px; min-height: 1.2rem;';
                        input.parentNode.appendChild(div);
                        return div;
                    })();

                if (!value) {
                    feedback.textContent = '';
                    input.style.borderColor = '';
                } else if (value.length < 2) {
                    feedback.textContent = '‚ÑπÔ∏è Enter cryptocurrency name or symbol';
                    feedback.style.color = '#fbbf24';
                    input.style.borderColor = '#fbbf24';
                } else {
                    feedback.textContent = '‚úÖ Ready to search';
                    feedback.style.color = '#4ade80';
                    input.style.borderColor = '#4ade80';
                }
            });
        }
    });
}

// Enhanced initialization with better error handling and performance monitoring
document.addEventListener('DOMContentLoaded', async function() {
    console.log('üöÄ Initializing Crypto Tools Pro...');
    const startTime = performance.now();

    try {
        // Initialize components in order of priority
        const initTasks = [
            { name: 'Input Validation', fn: addInputValidation },
            { name: 'Price Ticker', fn: updatePriceTicker },
        ];

        for (const task of initTasks) {
            try {
                console.log(`üìã Initializing ${task.name}...`);
                await task.fn();
                console.log(`‚úÖ ${task.name} initialized successfully`);
            } catch (error) {
                console.error(`‚ùå Failed to initialize ${task.name}:`, error);
            }
        }

        // Set up periodic updates with exponential backoff on failures
        let updateFailures = 0;
        const updateInterval = () => {
            const baseInterval = 60000; // 1 minute
            const backoffMultiplier = Math.pow(2, Math.min(updateFailures, 5)); // Max 32x backoff
            return Math.min(baseInterval * backoffMultiplier, 300000); // Max 5 minutes
        };

        const scheduleNextUpdate = () => {
            setTimeout(async () => {
                try {
                    await updatePriceTicker();
                    updateFailures = 0; // Reset on success
                } catch (error) {
                    updateFailures++;
                    console.error('Price ticker update failed:', error);
                }
                scheduleNextUpdate();
            }, updateInterval());
        };

        scheduleNextUpdate();

        // Performance monitoring
        const loadTime = performance.now() - startTime;
        console.log(`üéØ Crypto Tools Pro initialized in ${loadTime.toFixed(2)}ms`);

        // Set up connection monitoring
        window.addEventListener('online', () => {
            console.log('üü¢ Connection restored, updating data...');
            updatePriceTicker();
        });

        window.addEventListener('offline', () => {
            console.log('üî¥ Connection lost, switching to offline mode...');
        });

    } catch (error) {
        console.error('‚ùå Critical initialization error:', error);
        // Show user-friendly error message
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
            position: fixed; top: 20px; right: 20px; 
            background: rgba(255,107,107,0.9); color: white; 
            padding: 15px; border-radius: 8px; z-index: 9999;
            max-width: 300px; font-size: 14px;
        `;
        errorDiv.innerHTML = `
            <strong>‚ö†Ô∏è Initialization Error</strong><br>
            Some features may not work properly.<br>
            <small>Please refresh the page to try again.</small>
        `;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => errorDiv.remove(), 10000);
    }
});

// Enhanced click handler with better event delegation and animations
document.addEventListener('click', function(e) {
    // Handle tool card interactions
    if (!e.target.closest('.tool-card')) {
        const activeTools = document.querySelectorAll('.tool-form.active');
        activeTools.forEach(form => {
            form.style.transition = 'all 0.3s ease';
            form.style.opacity = '0';
            form.style.transform = 'translateY(-10px)';
            
            setTimeout(() => {
                form.classList.remove('active');
                form.style.opacity = '';
                form.style.transform = '';
            }, 300);
        });
        
        if (window.currentTool) {
            window.currentTool = null;
        }
    }

    // Handle copy buttons with enhanced feedback
    if (e.target.matches('[data-copy]') || e.target.closest('[data-copy]')) {
        const button = e.target.matches('[data-copy]') ? e.target : e.target.closest('[data-copy]');
        const textToCopy = button.getAttribute('data-copy') || button.textContent;
        
        navigator.clipboard.writeText(textToCopy).then(() => {
            const originalHTML = button.innerHTML;
            button.innerHTML = '<span style="color: #4ade80;">‚úÖ Copied!</span>';
            button.style.transform = 'scale(0.95)';
            
            setTimeout(() => {
                button.innerHTML = originalHTML;
                button.style.transform = '';
            }, 2000);
        }).catch(err => {
            console.error('Copy failed:', err);
            button.innerHTML = '<span style="color: #ff6b6b;">‚ùå Copy failed</span>';
            setTimeout(() => {
                button.innerHTML = button.getAttribute('data-original-text') || 'Copy';
            }, 2000);
        });
    }
});

// Utility function for safe localStorage operations
const SafeStorage = {
    set: (key, value) => {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        } catch (error) {
            console.error('LocalStorage set failed:', error);
            return false;
        }
    },
    
    get: (key, defaultValue = null) => {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (error) {
            console.error('LocalStorage get failed:', error);
            return defaultValue;
        }
    },
    
    remove: (key) => {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (error) {
            console.error('LocalStorage remove failed:', error);
            return false;
        }
    }
};

// Export utilities for global use
window.CryptoToolsAPI = {
    apiClient,
    SafeStorage,
    generateRandomPrivateKey,
    showResult
};

<script>
document.addEventListener('DOMContentLoaded', function() {
    let currentTool = null;
    
    function toggleTool(toolId, event) {
        event && event.stopPropagation();
        const allTools = document.querySelectorAll('.tool-form');
        const targetTool = document.getElementById(toolId);
        
        if (!targetTool) return;
        
        if (currentTool === toolId) {
            targetTool.classList.remove('active');
            currentTool = null;
        } else {
            allTools.forEach(tool => tool.classList.remove('active'));
            targetTool.classList.add('active');
            currentTool = toolId;
            targetTool.scrollIntoView({ behavior: 'smooth' });
        }
    }
    
    window.toggleTool = toggleTool;
});
</script>
</body>
</html>
